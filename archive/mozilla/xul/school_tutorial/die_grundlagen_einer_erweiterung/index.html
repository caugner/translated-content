---
title: Die Grundlagen einer Erweiterung
slug: Archive/Mozilla/XUL/School_tutorial/Die_Grundlagen_einer_Erweiterung
translation_of: Archive/Add-ons/Overlay_Extensions/XUL_School/The_Essentials_of_an_Extension
---
<p>{{ PreviousNext("XUL_School/Getting_Started_with_Firefox_Extensions", "XUL_School/Setting_Up_a_Development_Environment") }}</p>

<h2 id="Die_install.rdf_Datei">Die install.rdf Datei</h2>

<p>In der letzten Lektion haben wir uns den Inhalt der Hello World Erweiterung angesehen.Jetzt werfen wir einen Blick in diese Dateien und den Code, beginnen wir mit der install.rdf Datei. Sie können diese mit jedem Texteditor öffnen.</p>

<p>Die Datei ist in einem speziellen Dialekt von XML, <a class="external" href="http://en.wikipedia.org/wiki/Resource_Description_Framework">RDF</a> genannt formatiert. RDF wird eingesetzt als ein zentraler Speichermechanismus für Forefox, aber es ist jetzt durch ein einfacheres Datenbanksystem ersetzt worden. Wir werden später in diesem Tutorial beide Speichersystem besprechen.</p>

<p>Nehmen wir jetzt einen genaueren Blick auf die wichtigen Teile der Datei.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;em:id&gt;helloworld@xulschool.com&lt;/em:id&gt;</pre>
</div>
</div>

<p>Dies ist der eindeutige Bezeichner für die Erweiterung. Firefox benötigt diesen für die Unterscheidung eurer Erweiterung von anderen Erweiterungen, aufgrunddessen ist es erforderlich das Sie eine ID haben die eindeutig ist.</p>

<p>Es gibt zwei akzeptierte Standards für Add-on ID`s. Eine ist das E-Mail ähnliche Format in dem Hello World Beispiel, dieses sollte folgendermaßen aufgebaut sein <span style="color: #0000ff;"><em>&lt;project-name&gt;@&lt;yourdomain&gt;</em></span>. Die andere standard Vorgehensweise ist die Verwendung eines erzeugten <a class="external" href="http://en.wikipedia.org/wiki/Uuid">UUID</a>-Strings, welcher sehr unwahrscheinlich duppliziert ist. UNIX-basierte Systeme haben ein Kommandozeilenprogramm mit dem Namen <em>uuidgen </em>das diese UUID`S erzeugt. Auch gibt es herunterladbare Anwendungen für alle Plattformen die diese gnerieren. Die umschließenden Klammern sind nur ein Teil der Notation und hierbei handelt es sich nur um die gängige Praxis. Solange Ihre ID etwas eindeutiges hat, ist es OK diese in irgendeiner Form zu verwenden.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;em:name&gt;XUL School Hello World&lt;/em:name&gt;
&lt;em:description&gt;Welcome to XUL School!&lt;/em:description&gt;
&lt;em:version&gt;0.1&lt;/em:version&gt;
&lt;em:creator&gt;Appcoast&lt;/em:creator&gt;
<span class="code-comment">&lt;em:homepageURL&gt;https://developer.mozilla.org/en-US/docs/XUL_School&lt;/em:homepageURL&gt;</span></pre>

<p><span class="code-comment">Dies sind die Informationen die angezeigt werden bevor und nachdem die Erweiterung installiert ist, die Sie im Add-on Manager sehen können. Es können viele weitere Tags für Beteiligte und Übersetzer hinzugefügt werden.</span> Die <a href="/en-US/docs/Install_Manifests" title="en/Install Manifests">vollständige Spezifikation</a> der install.rdf Datei beinhaltet alle Details.</p>

<p>Seit Erweiterungen in mehrere Sprachen übersetzt werden können, ist es oft notwendig die Erweiterungsbeschreibung zu übersetzen, oder sogar deren Namen. Eine lokal begrenzte Beschreibung und Name kann mit dem folgenden Code hinzugefügt werden.</p>
</div>
</div>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;em:localized&gt;
  &lt;Description&gt;
    &lt;em:locale&gt;es-ES&lt;/em:locale&gt;
    &lt;em:name&gt;XUL School Hola Mundo&lt;/em:name&gt;
    &lt;em:description&gt;Bienvenido a XUL School!&lt;/em:description&gt;
  &lt;/Description&gt;
&lt;/em:localized&gt;</pre>
</div>
</div>

<p>Der es-Es lokale String bedeutet das dies die spanische (es) lokalisierung für Spanien (ES) ist. Sie können soviele <em>&lt;em:localized&gt; </em>Sektionen hinzufügen wie Sie benötigen. Für Friefox 2, ist die lokaliesierungs Datei <a href="/en-US/docs/Localizing_extension_descriptions#Localizing_before_Gecko_1.9">etwas komplizierter</a>. Wir werden im weiteren die lokalisierung in diesem Kapitel besprechen.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;em:type&gt;2&lt;/em:type&gt;</pre>
</div>
</div>

<p>Dies bestimmt, dass das Add-on als eine Erweiterung installiert wird. Sie können die verschieden möglichen Typen in der <a href="/en-US/docs/Install_Manifests#type">install.rdf Spezifikation</a> nachlesen.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;em:targetApplication&gt;
  &lt;Description&gt;
    &lt;em:id&gt;{ec8030f7-c20a-464f-9b0e-13a3a9e97384}&lt;/em:id&gt;
    &lt;em:minVersion&gt;4.0&lt;/em:minVersion&gt;
    &lt;em:maxVersion&gt;10.*&lt;/em:maxVersion&gt;
  &lt;/Description&gt;
&lt;/em:targetApplication&gt;
</pre>
</div>
</div>

<p>Dieser Knoten spezifiziert die Zielanwendung und die Zielversion für die Erweiterung, in der Regel Firefox von Version 4 bis zu Version 10. Die UUID ist die eindeutige ID von Firefox. Ander Mozilla und Mozillabasierte Anwendenungen wie z.B. Thunderbirf und Seamonkey besitzen ihre eigene. Es ist möglich eine Erweiterung zu besitzen die auf mehreren Anwendungen und Versionen arbeitet. Als Beispiel , wenn Sie eine Firefox-Erweiterung entwickeln, wird es in der Regel wenig Aufwand erfordern diese zu SeaMonkey zu portieren, welches ähnliche Features und Benutzeroberflächen besitzt.</p>

<p>Die min und max Version Angabe spezifiziert den Versionbereich in dem die Erweiterung installiert werden kann. Hier gibt es mehr Informationen über das <a href="/en-US/docs/Toolkit_version_format" title="en/Toolkit version format">Versionsformat.</a> Wenn die Anwendung nicht mit dem Versionsbereich übereinstimmt, wird es Ihnen nicht erlaubt sein die Anwendung zu installieren, oder die Erweiterung wird mit einem gesetzten deaktiviert Status installiert. Benutzer können Versionsüberprüfungen über die Einstellungen deaktivieren, oder durch die Installation von Add-on`s wie den <a class="link-https" href="https://addons.mozilla.org/en-US/firefox/addon/15003" title="https://addons.mozilla.org/en-US/firefox/addon/15003">Add-on Compatibility Reporter</a>. Mit Anfang des Firefox 11, werden Add-on`s standardmäßig als kompatiel betrachtet und Firefox wird den Versionsbereich weitesgehend ignorieren. Das Testen Ihrer Add-on`s auf allen Firefoxversionen ist immer empfehlenswert.</p>

<p>Diese Informationen werden von Firefox und anderen Mozillaanwendungen benötigt um ein Add-on zu installieren. Jeder Fehler oder fehlende Informationen werden den Installationsprozess zum Scheitern bringen, oder die Erweiterung wird mit einem gesetzten deaktvitiert Status installiert.</p>

<h2 id="The_chrome.manifest_File">The chrome.manifest File</h2>

<blockquote>
<p><span style="color: #0000ff;">Chrome is the set of user interface elements of the application window that are outside of a window's content area.</span> Toolbars, menu bars, progress bars, and window title bars are all examples of elements that are typically part of the chrome.</p>
</blockquote>

<p>Auszug aus der <a href="/en-US/docs/Chrome_Registration" title="en/Chrome Registration">Chrome Registration</a>.</p>

<p>Mit anderen Worten, Chrome ist alles was Sie im Firefox sehen. Alle Firefoxfenster können betrachtet werden als Zusammensetzung zweier Teilbereiche: (1) Chrome und (2) ein möglicher Inhaltsbereich, wie das das in Firefox die Anzeige von Webseiten übernimmt. Fenster wie das Downloadfenster sind ausschließlich Chrome. Der Großteil des Programmcodes einer Erweiterung liegt im Chromeordner, wie bei dem Hello World Beispiel.</p>

<p>Wie wir in der Ordnerstruktur der entpackten Erweiterung gesehen haben, Chrome ist zusammengesetzt aus drei Teilbereichen: <span style="color: #0000ff;">content</span>, <span style="color: #0000ff;">locale</span> und <span style="color: #0000ff;">skin</span>. Diese drei sind notwendig für die meisten Erweiterungen. Wenn wir die <em>chrome.manifest</em>-Datei erneut öffnen (nochmals jeder Texteditor kann hierfür verwendet werden), werden wir diese drei angesprochenen Teilbereiche erkennen können.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">content   xulschoolhello              content/
skin      xulschoolhello  classic/1.0 skin/
locale    xulschoolhello  en-US       locale/en-US/
</pre>
</div>
</div>

<p><span style="color: #0000ff;">Die <em>chrome.manifest</em> Datei lässt Firefox wissen, wo es nach den Chromedateien zu suchen hat.</span> Der Text ist formatiert so das er dem Aussehen einer Tabelle gleicht, aber dies ist nicht notwendig. Der Parser ignoriert aufeinanderfolgende Leerzeichen.</p>

<p>Das erste Wort in einer Zeile teilt Firefox mit, was angegeben ist (content, skin, locale, oder weiter Angaben, die später erwähnt werden). Das zweite ist der Paketname, was wir demnächst erklären werden.</p>

<p>Darstellungs und lokale Packete besitzen einen dritten Wert, um zu spezifizieren welche lokale oder welche Darstellung sie erweitern. Es können mehrere Darstellungs und lokale Einträge für unterschiedliche Darstellung und lokalisierungs Variablen eingetragen werden. Der häufigste Fall ist es einen Darstellungeintrag für die gloabe Darstellung zu haben , <em>classic/1.0</em>, und mehrere lokale Einträge, einen für jede Übersetzung. Am Ende wird eine Ortsvariable spezifizerit.</p>

<p>Es gibt einige zusätzliche Optionen, die in die Einträge der <em>chrome.manifest</em> Datei eingefügt werden können. Diese sind auf der <a href="/en-US/docs/Chrome_Registration" title="en/Chrome Registration">Chrome Registration</a> Seite dokumentiert. Beachtenswert ist, wir können Einträge erstellen, die Betriebssystem spezifisch sind. Dies ist wichtig, weil das Aussehen des Browsers ist sehr unterschiedlich für jedes Betriebssystem. Wenn es notwendig ist, dass Ihre Erweiterung auf verschieden Systemen unterschiedlich aussieht, könnten wir das Manifest so anpassen, dass es aussieht wie hier:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">content   xulschoolhello              content/
skin      xulschoolhello  classic/1.0 skin/unix/
skin      xulschoolhello  classic/1.0 skin/mac/ os=Darwin
skin      xulschoolhello  classic/1.0 skin/win/ os=WinNT
locale    xulschoolhello  en-US       locale/en-US/
</pre>
</div>
</div>

<p>Über diesen Weg können wir unterschiedliche Darstellungen für Windows, Mac OS X und Linux (plus anderer unix-ähnlichen Systemen) haben, die jede von ihnen in einer seperaten Ordnerstruktur definiert ist. Seit die meisten anderen System Unix-basiert sind, ist die "unix" Darstellung der Standard ohne weitere Marker.</p>

<h2 id="Chrome">Chrome</h2>

<p>Wie zuvor angesprochen Chrome besteht aus 3 Teilbereichen: content, locale und skin. Der content-Bereich ist der wichtigste Bereich, beinhaltet die Benutzerschnittstelle (XUL) und Skriptdateien (JA). Der Darstellungsbereich beinhaltet die Dateien die das Meiste des Aussehen und Verhalten der UI (mit Einsatz von CSS und Bildern, wie bei Webseiten) definieren. Abschließend enthält der locale Bereich den gesamten in der Erweiterung verwendeten Text, in DTD und die Einstellungsdateien. Diese Aufteilung erlaubt es anderenen Entwicklern Themes zu entwickeln die die Darstellung ersetzen und Übersetzer für andere Sprachen, all das ohne das eine Änderung der Erweiterung oder des Programmcodes notwendig wäre. Dies gibt Firefox Erweiterungen eine großartige Flexibiltät.</p>

<p>Chrome Dateien werden über das Chrome-Protokoll zugewiesen. So sieht eine chrome URI aus:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">chrome:<span class="code-comment">//packagename/section/path/to/file</span></pre>

<p><span class="code-comment">Wenn ich beispielsweise Zugriff auf die Datei</span> <em>browserOverlay.xul </em>haben möchte, wäre die Chrome URI <em>chrome://xulschoolhello/content/browserOverlay.xul</em>.</p>
</div>
</div>

<p>Wenn Sie zu viele Dateien im content Bereich habe und Sie diese in Subordner organisieren wollen, gibt es nichts was Sie im <em>chrome.manifest</em> ändern müssen, alles was Sie benötigen ist den richtigen Pfad nach <em>content</em> in die URI hinzuzufügen.</p>

<p>Darstellungs- und Regions-Dateien arbeiten in der selben Art und Weise, und Sie müssen keine Darstellungs- oder Regions -Namen festleggen. Also um auf die DTD-Datei in der Hello Wolrd Erweiterung zuzugreifen, ist der Chromepfad <em>chrome://xulschoolhello/locale/browserOverlay.dtd</em>. Firefox was anschließend nach welcher Region es abrufen muss.</p>

<p>Hier ist ein interesantes Experiment. Öffne ein neues Firefox Tab, tippe <em>chrome://mozapps/content/downloads/downloads.xul </em>in deine Adressleiste und drücke Enter. Überrascht? Sie haben soeben das Downloadfenster in einem Firefoxtab geöffnet! Sie können auf jede Chromedatei zugreifen indem Sie die URI in die Addressleite eintippen. Dies kann nützlich werden, wenn du Skriptdatei untersuchen möchtest, die ein Teil von Firefox, anderen Erweiterungen oder deine eigene sind. Die meisten dieser Dateien werden als Textdatei geöffnet, mit der Ausnahme von XUL-Dateien, diese werden ausgeführt und so dargestellt wie Sie diese normalerweise in einem Fenster sehen würden.</p>

<h3 id="Content">Content</h3>

<p>Es gibt 2 Dateien im content Verzeichnis. Sehen wir uns zuerst die XUL-Datei an.</p>

<p>Bei XUL-Dateien handelt es sich um XML-Dateien, die Benutzeroberflächenelemente in Firefox und Firefoxerweiterungen definieren. XUL wurde von HTML inspiriert, von daher werden Sie viele Ähnlichkeiten zwischen den beiden feststellen. Wie auch immer, XUL ist auch eine Verbesserung gegenüber HTML, die aus vielen Fehlern gelernt hat, die bei der Entwickliung von HTML gemacht wurden. XUL erlaubt Ihnen reichere und interaktivere Oberflächen zu erstellen, als mit HTML, oder zumindest macht XUL es einfacher.</p>

<p>XUL-Dateien defineren in der Regel eine von zwei Dingen: Fenster oder Overlays. Die Datei die Sie zuvor geöffnet haben, <em>downloads.xul</em>, beinhaltet den Programmcode der das Downloadfenster definiert. Die XUL-Datei die in der Hello World Erweiterung eingeschlossen ist, ist eine Overlay. Ein Overlay erweitert ein vorhandes Fenster, fügt diesem neue Elemente hinzu oder ersetzt einige der Elemente in ihm. Die Zeile die wir in der <em>chrome.manifest</em> Datei übersprungen haben gibt an das es sich bei dieser XUL-Datei um ein Overlay für das Browserhauptfenster handelt:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">overlay chrome:<span class="code-comment">//browser/content/browser.xul  chrome://xulschoolhello/content/browserOverlay.xul</span></pre>

<p><span class="code-comment">Durch diese Zeile weiß Firefox, dass es die Inhalte aus </span><em>browserOverlay.xul </em>verwenden muss und diese über das Browserhauptfenster, <em>browser.xul </em>legen muss. Sie können für jedes Fenster oder Dialog in Firefox ein Overlay festlegen, aber ein Overlay über das Browserhauptfenster zu legen ist der mit Abstand häufigste Fall.</p>

<p>Jetzt nehme wir einen Blick auf unsere XUL-Datei. Wir werden die ersten paar Zeilen überspringen, weil diese sich auf die Darstellung und die Region beziehen, diese werden wir im späteren behandeln.</p>
</div>
</div>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;overlay id="xulschoolhello-browser-overlay"  xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"&gt;</pre>
</div>
</div>

<p>Das Wurzelelement in dieser Datei ist ein <em>Overlay</em>. Andere XUL-Dokumente nutzen den window oder dialog Tag. Das Element besitzt einie eindeutige ID, welche Sie bei den meisten Element in Ihrer XUL vergeben sollten. Das zweite Attribut ist der Namensraum, diesen sollten Sie immer in Ihrem XUL-Wurzelelment definieren. Es sagt aus, dass dieser Knoten und alle Kindknotten XUL-Element sind. Sie brauchen nur änderungen an der Namensraum deklaration vornehmen, wenn Sie verschiedene Arten eines Inhalts in dem gleichen Dokument kombinieren, wie z.B. XUL mit HTML oder SVG.</p>

<div class="panel" style="border-width: 1px;">
<div class="panelContent">
<div class="note">You may have noticed the naming we use on several places, such as the id <em>xulschoolhello-browser-overlay</em>. This is the namespacing standard that we use to avoid conflicts with Firefox and other extensions, as well as making some development tasks easier. We namespace all ids and style classes in overlay elements because they will be mixed with other elements in the main browser window. If we used generic ids like <em>container</em> or <em>input</em>, they will likely conflict with ids used within Firefox, or with ids from other extension overlays. Using namespaces minimizes compatibility problems with other extensions. We use camel casing for file names, and all lower case with dashes for element ids and CSS style class names, but you're free to use your own system.</div>
</div>
</div>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;script type=<span class="code-quote">"application/x-javascript"</span>   src=<span class="code-quote">"chrome:<span class="code-comment">//xulschoolhello/content/browserOverlay.js"</span> /&gt;</span></pre>
</div>
</div>

<p>Wie in HTML, wird hierdurch eine JavaScript-Datei eingebunden. Sie können soviele Skriptelement in ein XUL-Dokumente einbinden wie Sie benötigen. Wir werden uns diesen Programmcode später noch ansehen.</p>

<div class="panel" style="border-width: 1px;">
<div class="panelContent">
<div class="note">You also probably noticed how we format our code, and wonder about the rules we follow. Our general rule on line length is not having lines longer than 80 characters. This feels very restrictive, specially with XML files, but the number was chosen to allow pretty much any text editor to handle these files easily. Even old command line editors work well with files that cut their lines at 80 characters. The tabulation is very straightforward: 2 blank space indents. We never use actual tab characters, with the exception of Makefiles, which will be covered later on. Most of our coding standards are based on Mozilla's or other known and used standards.</div>
</div>
</div>

<p>Wir werden etwas Programmcode übersprinder, der im Regionsbereich behandelt wird, um mit dem wichtigsten Bereich von content fortzufahren.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;menubar id="main-menubar"&gt;
  &lt;menu id="xulschoolhello-hello-menu" label="&amp;xulschoolhello.hello.label;"
    accesskey="&amp;xulschoolhello.helloMenu.accesskey;" insertafter="helpMenu"&gt;
    &lt;menupopup&gt;
      &lt;menuitem id="xulschoolhello-hello-menu-item"
        label="&amp;xulschoolhello.hello.label;"
        accesskey="&amp;xulschoolhello.helloItem.accesskey;"
        oncommand="XULSchoolChrome.BrowserOverlay.sayHello(event);" /&gt;
    &lt;/menupopup&gt;
  &lt;/menu&gt;
&lt;/menubar&gt;

&lt;vbox id="appmenuSecondaryPane"&gt;
  &lt;menu id="xulschoolhello-hello-menu-2" label="&amp;xulschoolhello.hello.label;"
    accesskey="&amp;xulschoolhello.helloMenu.accesskey;"
    insertafter="appmenu_addons"&gt;
    &lt;menupopup&gt;
      &lt;menuitem id="xulschoolhello-hello-menu-item-2"
        label="&amp;xulschoolhello.hello.label;"
        accesskey="&amp;xulschoolhello.helloItem.accesskey;"
        oncommand="XULSchoolChrome.BrowserOverlay.sayHello(event);" /&gt;
    &lt;/menupopup&gt;
  &lt;/menu&gt;
&lt;/vbox&gt;
</pre>
</div>
</div>

<p>Das ist der Code, der das Hello World-Menü dem Browserfenster hinzufügt.</p>

<p>Darin enthalten sind zwei ähnliche Codeblöcke, dass ist dadurch begründet das in modernen Versionen von Firefox, insbesondere unter Windows, ein einzelner Firefox Menübutton mit vereinfachten Menüoptionen, anstatt einer umfangreichen Menübar dargestellt wird. Der zweite Codeblock bezieht sich auf alle üblichen Buttonprozesse; der erste Codeblock bezieht sich auf alle anderen Prozesse. Setze den Hacken Menüleiste unter dem Optionsmenü im Menübutton, um die Anzeige des klassischen Menüs unter Windows und einigen Linuxdistributionen zu aktivieren.</p>

<p>Um diesen Code zu schreiben, benötigen wir etwas Wissen über den XUL-Code in <em>browser.xul</em>. Wir müssen wissen, dass die ID des rechten Fläche in dem undefinierten Menü <em>appmenuSecondaryPane</em> ist. Wir werden ein eigenes Menü hinzufügen und Firefox mitteilen dieses rechts nachdem Add-on-Element in die Fläche hinzuzufügen. Dies ist die Festlegung des Attributes:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">insertafter=<span class="code-quote">"appmenu_addons"</span>
</pre>
</div>
</div>

<p><em>appmenu_addons</em> ist die ID des Menüelements, dass mit dem Add-on-Menü im Hauptmenü in verbindung steht. Wir werden später sehen wir die Dinge wie die ID von Browserelementen ermitteln können, aber jetzt sehen wir uns die Elemente aus denen sich das Hello World-Menü zusammensetzt.</p>

<p>Für das klassische Menü, fügen wir das Hello World-Menü rechts in das "Wurzelverzeichnis" der Menüs hinzu, so dass es sehr einfach zu finden ist, aber in der Praxis ist es nicht notwendig. Stellen Sie sich vor was passieren würde, wenn alle Erweiterungen ein Menü im oberen Menü hinzufügen würden; ein paar Erweiterungen zu haben würde es dann außen lassen wie die Kontrollanzeige eines Flugzeuges, voller Knöpfe und Schalter. Im Falle des zusammengesetzen Menüs, sind die Dinge aufgrund von zu wenigen Optionen etwas mehr kompliziert. Wenn dein Menüitem in den Webentwicklerbereich passt empfiehlt es sich es dort zu platzieren. Andererweise ist das Wurzelmenü möglicherweise der einzige sinnvolle Ort.</p>

<p>Ein empfehlenswerter Ort für Menüs in dem Klassikmenü ist unter dem Extrasmenü, von daher sollte der Code in etwa so aussehen:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;menupopup id=<span class="code-quote">"menu_ToolsPopup"</span>&gt;
  &lt;menu id=<span class="code-quote">"xulschoolhello-hello-menu"</span> label=<span class="code-quote">"&amp;</span><span class="code-quote">xulschoolhello</span><span class="code-quote">.hello.label;"</span>
    accesskey=<span class="code-quote">"&amp;</span><span class="code-quote">xulschoolhello</span><span class="code-quote">.helloMenu.accesskey;"</span>
    insertbefore=<span class="code-quote">"</span>devToolsEndSeparator<span class="code-quote">"</span>&gt;
    &lt;menupopup&gt;
      &lt;menuitem id=<span class="code-quote">"</span><span class="code-quote">xulschoolhello</span><span class="code-quote">-hello-menu-item"
      </span>  label=<span class="code-quote">"&amp;</span><span class="code-quote">xulschoolhello</span><span class="code-quote">.hello.label;"</span>
        accesskey=<span class="code-quote">"&amp;</span><span class="code-quote">xulschoolhello</span><span class="code-quote">.helloItem.accesskey;"</span>
        oncommand=<span class="code-quote">"XULSchoolChrome.BrowserOverlay.sayHello(event);"</span> /&gt;
    &lt;/menupopup&gt;
  &lt;/menu&gt;
&lt;/menupopup&gt;
</pre>
</div>
</div>

<p>Wir legen das Menü über das tieferlegende in dem XUL-Baum, aber das spielt keine Rolle weil alles was wir benötigen ist die ID des Elements das wir Überblenden wollen. In diesem Fall ist dies das Menüpopup-Element das sich innerhalb des Extras. Das<em>insertbefore</em> Attribut teilt Firefox mit das Menü im unteren Bereich des Entwicklerextrasbereich hinzuzufügen, über den abschließenden Seperatoren. Wir werden im späteren des Tutorials über Menüs sprechen.</p>

<p>Nehmen wir jetzt einen Blick auf den  eigentlichen Code:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">oncommand=<span class="code-quote">"XULSchoolChrome.BrowserOverlay.sayHello(event);"</span>
</pre>
</div>
</div>

<p>Dieses Attribute beschreibt einen Eventhandler. . Das <em>command</em> event ist das am meisten genutzte in Firefox, da es mit den Hauptaktionen der meisten UI-Elemente kommuniziert. Der Nutzen der Attribute ist der JacaScript-Code der eine Funktion aufruft. Diese Funktion ist in er der JS-Datei definiert, das mit Skript-Tag eingebunden wird. Die JS-Funktion wird aufgerufen wenn der Benutzer auf einen Menüeintrag im Hello World-Menü aufruft. Alle Eventhandler definieren ein spezielles Objekt namens <em>event</em>, welches normalerweise ausreicht um ein Argument an die Funktion zu übergeben. Eventhandler werden im späteren genauer definiert.</p>

<p>Nun werfen wir einen Blick in die JavaScript-Datei und und sehen uns an wenn das Event ausgeführt wird.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">/**
 * XULSchoolChrome namespace.
 */
if ("undefined" == typeof(XULSchoolChrome)) {
  var XULSchoolChrome = {};
};</pre>
</div>
</div>

<p>Der <em>XULSchoolChrome</em> Namensraum ist definiert. Alle Objekte und Variablen die wir i JavaScript definieren sind global, das bedeutet das Skripte in Firefox und andere Erweiterungen können diese sehen und mit Ihnen interagieren. Dies bedeudet also dass wenn wir ein Objekt <em>MenuHandler definieren </em>oder einige generische Namen, ist es wahrscheinlich das es mit einem extierenden Objekt in Konflikt steht. Was wir hier machen ist ein einzelnes globales Objekt zu definieren: <em>XULSchoolChrome</em>. Nun wissen dass alle unsere Objekte sind innerhalb dieses Objekts, welches unwahrscheinlich duplliziert oder überschrieben wird von anderen Erweiterungen.</p>

<p>Sie können hier mehr über den <a href="/en-US/docs/JavaScript/Reference/Operators/typeof" title="en/Core JavaScript 1.5 Reference/Operators/Special Operators/typeof Operator"><span class="external">typeof operator</span></a> erfahren. Wenn Sie nicht mit JavaScript oder der besonderen Syntax, ein Objekt mit {} zu intialisieren ist identisch mit es mit <em>new Object() </em>zu intialisieren.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">/**
 * Controls the browser overlay <span class="code-keyword">for</span> the Hello World extension.
 */
XULSchoolChrome.BrowserOverlay = {</pre>
</div>
</div>

<p>Sclussendlich ist <em>BrowserOverlay </em>unser Objekt. Ein Objekt in solcher langen und ausführlichen Art und Weise zu benennen und refernzieren kann sich am Anfang unkomfirtabel anfühlen, aber es ist den Aufwand wert.</p>

<div class="panel" style="border-width: 1px;">
<div class="panelContent">
<div class="note">We use <a class="external" href="http://java.sun.com/j2se/javadoc/writingdoccomments/index.html">Javadoc</a> style comments on all namespaces, objects and object members. This is a similar standard to the one used in Mozilla code, and some tools can generate documentation automatically from Javadoc.</div>
</div>
</div>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">sayHello : function(aEvent) {
  let stringBundle = document.getElementById("xulschoolhello-string-bundle");
  let message = stringBundle.getString("xulschoolhello.greeting.label");

  window.alert(message);
}</pre>
</div>
</div>

<p>Und Schlussendlich ist dass unsere Funktionsdeklaration. Drei Zeilen sind alles was wir benötigen. Die erste Zeile in dem Body der Funktion deklariert eine Variable die das <a href="/en-US/docs/XUL/stringbundle" title="en/XUL/stringBundle">stringbundle</a>-Element beinhaltet, das im Overlay definiert ist. Die Variable ist deklariert durch die Verwendung von <em>let, </em>dass <em>var </em>ähnlich ist aber einen enger begrenzten Bereich besitzt. Hier können Sie mehr über die <a href="/en-US/docs/JavaScript/Reference/Statements/let" title="let"><span class="external">let deklaration </span></a>nachlesen.</p>

<p>WIe auch im regulären JS, können wir das <a href="/en-US/docs/DOM" title="en/DOM"><span class="external">DOM</span></a> (Document Object Model) nutzen um dass XUL-Dokument zu manipulieren.Als erstes bekommen wir eine referenze auf das <a href="/en-US/docs/XUL/stringbundle" title="en/XUL/stringbundle"><span class="external">stringbundle-Element</span></a>  in dem Dokument. Dies ist ein spezielles Element das es uns erlaubt beschränkte Strings dynamisch zu erhalten, nur durch die bereitstellung eines "key`s" der Den String identifiziert. Das macht die zweite Zeile. Wir rufen die <a href="/en-US/docs/XUL/stringbundle#m-getString" title="en/XUL/stringbundle#m-getString">getString Methode</a> des bundle-Elements udn bekommen die begrenzte Meldung angeziegt. Anschließende rufen wir die <a href="/en-US/docs/DOM/window.alert" title="en/DOM/window.alert">window.alert</a>-Funktion auf, wie wir das auch in einem HTML-Dokument machen würden.</p>

<h3 id="Locale">Locale</h3>

<p>Es gibt zwei Arten von locale-Dateien: DTD und Einstellungen, und in diesem Beispiel werden wir beide benutzen. DTD ist der effizenteste Weg um Text in XUL anzuzeigen, von daher sollten Sie es benutzen wann immer es möglich ist. Es ist etwas unflexibel, so kann es nicht für dynamisch erzeugten Text verwendet werden, folglich gibt es eine Notwendigkeit um auf regionale Strings zuzugreifen.</p>

<p>Werfen wir einen Blick zurück auf den Menücode, dort haben Sie unter Umständen einge Attribute wie diese bemerkt:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">label=<span class="code-quote">"&amp;xulschoolhello.hello.label;"</span> accesskey=<span class="code-quote">"&amp;xulschoolhello.helloItem.accesskey;"</span></pre>
</div>
</div>

<p>Diese Attribute definieren den Text den Sie in den Menüs sehen,  es sind String-keys die in unserer DTD-Datei definiert sind, <em>browserOverlay.dtd</em>. Die DTD-Datei wurd mit folgendem Code in die XUL-Datei eingefügt:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;!DOCTYPE overlay SYSTEM "chrome://xulschoolhello/locale/browserOverlay.dtd" &gt;</pre>
</div>
</div>

<p>Und in der DTD-Datei können Sie die Zuordnung von Keys und regionalen Strings sehen:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;!ENTITY xulschoolhello.hello.label            <span class="code-quote">"Hello World!"</span>&gt;
&lt;!ENTITY xulschoolhello.helloMenu.accesskey    <span class="code-quote">"l"</span>&gt;
&lt;!ENTITY xulschoolhello.helloItem.accesskey    <span class="code-quote">"H"</span>&gt;</pre>
</div>
</div>

<p>Beachte das Sie in den XUL-Dateien den String mit &amp; und ; umschließen, wohingegen sie in eriner DTD-Datei nur den Key spezifizieren. Sie erhalten womöglich sonderbare Fehlermeldungen oder Zuordnungen wenn Sie dass nicht beachten.</p>

<p>Zugangs Key`s sind Shortcuts die es Ihnen erlauben, nur mit der Tastatur schnell durch ein Menü zu navigieren. Sie sind auch der einzige Weg durch die Menüs zu navigieren für Menschen die eine <a href="http://www.dict.cc/deutsch-englisch/Barrierefreiheit.html">Barrierefreiheit</a> benötigen, durch teilweise oder vollkommene Blindheit oder durch körperliche Eingeschränktheit die, dass nutzen einer Maus sehr schwierig oder unmöglich machen. Sie können die Zugangs-Key`s unter Windows leicht erkennen, weil der Buchstabe der mit dem Zugangs-Key in Verbindung steht unterstrichen ist, wie in der folgenden Abbildung.</p>

<div>
<p><img alt="" class="internal" src="/@api/deki/files/4226/=accesskeys.png" style="width: 167px; height: 58px;"></p>
</div>

<p>DIe meisten Benutzeroberflächen Schaltflächen besitzen ein <em>accesskey</em> Atribut, und Sie sollten es benutzen. Der Wert eines Zugangs-Key`s ist lokal beschränkt, weil er einem Buchstaben im Labeltext entsprechen soll. Sie sollten darauf achten es zu vermeiden Zugangs-Key´s zu wiederholen. Als Beispiel, innerhalb eines Menüs oder Untermenüs sollten Zugangs-Key`s nicht wiederholt werden. In einem Fenster müssen Sie noch vorsichtiger sein bei der Auswahl von Zugang-Key`s weil es dort normalerweise eine größere Anzahl an Schaltflächen gibt. Besonders vorsichtig müssen Sie sein wenn Sie Zugangs-Key`s für eine Overlay auswahlen. In unserem Fall, können wir den Buchstaben "H" nicht als einen Zugangs-Key im Hauptmenü verwenden, weil dieser sich mit dem Zugangs-Key den Hilfemenüs überschneiden würde. Das selbe gilt für das "W" und das Fenstermenü unter Mac OS. Von daher haben wir den Buchstaben "l" zugewiesen.</p>

<p>DTD-Strings werden aufgelöst und gesetzt wenn das Dokument lädt. Wenn Sie den <em>label-Attribute </em>Wert für das Hello World-Menü mit hilfe von DOM abfragen, erhalten Sie den begrenzten String und nicht den String-Key. Sie können nicht dynamischen den Wert von Attributen mit einem neuen DTD-Schlüssel ändern, Sie müssen den neuen Wert direkt setzen.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="brush: js">let helloItem = document.getElementById(<span class="code-quote">"xulschoolhello-hello-menu-item"</span>);

<span class="code-comment">// The alert will say <span class="code-quote">"Hello World!"</span>
</span>alert(helloItem.getAttribute(<span class="code-quote">"label"</span>));
<span class="code-comment">// Wrong
</span>helloItem.setAttribute(<span class="code-quote">"label"</span>, <span class="code-quote">"&amp;</span><span class="code-quote">xulschoolhello</span><span class="code-quote">.hello2.label;"</span>);
<span class="code-comment">// Better
</span>helloItem.setAttribute(<span class="code-quote">"label"</span>, <span class="code-quote">"Alternate message"</span>);
<span class="code-comment">// Right!
</span>helloItem.setAttribute(<span class="code-quote">"label"</span>, someStringBundle.getString(<span class="code-quote">"</span><span class="code-quote">xulschoolhello</span><span class="code-quote">.hello2.label"</span>));</pre>
</div>
</div>

<p>Das ist der Grund warum DTD-String keine Lösung für alle beschränkten Fälle sind, and der Grund warum wir oft Stringpakete in XUL-Dateien einbinden müssen.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;stringbundleset id="stringbundleset"&gt;
  &lt;stringbundle id="xulschoolhello-string-bundle"
    src="chrome://xulschoolhello/locale/browserOverlay.properties" /&gt;
&lt;/stringbundleset&gt;</pre>
</div>
</div>

<p>Das <a href="/en-US/docs/XUL/stringbundleset" title="en/XUL/stringbundleset">stringbundleset</a>-Element ist nur ein Container für <a href="/en-US/docs/XUL/stringbundle" title="en/XUL/stringbundle">stringbundle</a>-Elemente. Hiervon sollte eines pro Dokument geben, dies ist auch der Grund warum wir das <em>stringbundleset</em> in der browser.xul überschreiben, daher die sehr generische ID.  Wir fügen keine <em>insertbefore</em> oder <em>insertafter</em> Attribute ein weil die Reihenfolge der Stringpakete keine Rolle spielt. Das Element ist vollständig unsichtbar. Wenn Sie keine Ordnungsattribute in ein Overlay-Element einfügen, wird Firefox Ihr Element als letztes Kindelement des Elternelements betrachten.</p>

<p>Alles was Sie für das Stringpaket benötigen ist eine ID (um später auf das Element zugreifen zu können und den Chrome-Pfad der Einstellungsdatei. Und natürlich die Einstellungsdatei:</p>

<pre class="code-java  language-html"><code class="language-html">xulshoolhello.greeting.label = Hi! How are you?</code></pre>

<p>Die Leerzeichen vor und nach dem Gleichheitszeichen werden ignoriert. Genauso wie in der install.rdf, Kommentare können durch das "#" Zeichen am Anfang einer zeile hinzugefügt werden. Leere Zeilen werden ebenso ignoriert.</p>

<p>Sei werden oft einen dynamischen Inhalt als Teil eines begrenzten Strings einbinden wollen, wie wenn Sie den Nutzer über den Status der Erweiterung informieren wollen. Als Beispiel: "Es wurden 5 der Suchanfrage entprechende Wörter gefunden". Ihre erste Idee ist möglicherweise einfach Strings zu verketten und eine "Found" Eigenschaft und eine weitere "words matching..." Eigenschaft zu verwenden. Dies ist keine Gute Idee. Sie behindert nur in einem großen Maße die Arbeit von Übersetzern und Grammatikregeln der verschieden Sprachen ändern möglicherweise den Aufbau des Satzes. Aus diesem Grund ist es besser Parameter in den Eienschaften zu verwenden.</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">xulshoolhello.search.label = Found %S words matching the search query!</pre>
</div>
</div>

<p>Wenn Sie den <a href="/en-US/docs/XUL/stringbundle#m-getFormattedString" title="en/XUL/stringbundle#m-getFormattedString">getFormattedString</a> anstatt des <em>getString </em>verwenden um auf den begrenzten String zuzugreifen. Glücklicherweise müssen wir durch dass nicht mehrere Eigenschaften anlegen, hierdurch wird das Leben für Übersetzer einfacher. Sie können mehr über das in dem <a href="/en-US/docs/XUL_Tutorial/Property_Files#Text_Formatting" title="en/XUL Tutorial/Property Files#Text Formatting">Text Formatting Bereich</a> des XUL Tutorial nachlesen. Werfen Sie auch einen Blick auf die <a href="/en-US/docs/Localization_and_Plurals" title="en/Localization and Plurals">Plurals and Localization</a> Artikel, die die Lokalisierungsfunktionen behandeln und es Ihnen weiterhin erlauben das letzte Beispiel zu verbessern, um verschiedene Arten von Pluralformen zu verarbeiten die auch Sprachabhängig sind.</p>

<h3 id="Skin">Skin</h3>

<p>XUL zu gestalten ist dem gestalten von HTML sehr ähnlich. Wir werden uns einige Unterschiede ansehen wenn wir das XUL-Box-Modell und andere fortgeschritten Themen. Es gibt nicht viel was Sie in bei einem minimalen Menü und einer einfachen Warnmeldung gestalten können, da die Hello World ERweiterung nur eine leere CSS-Datei und eine vorgeschriebene globale Skin-Datei beinhaltet:</p>

<div class="code panel" style="border-width: 1px;">
<div class="codeContent panelContent">
<pre class="code-java">&lt;?xml-stylesheet type=<span class="code-quote">"text/css"</span> href=<span class="code-quote">"chrome:<span class="code-comment">//global/skin/"</span>  ?&gt;
</span>&lt;?xml-stylesheet type=<span class="code-quote">"text/css"</span>
  href=<span class="code-quote">"chrome:<span class="code-comment">//xulschoolhello/skin/browserOverlay.css"</span>  ?&gt;</span></pre>
</div>
</div>

<p>Die globale Skin-CSS-Datei enthält alle standard Styles für alle XUL-Elmente und Fenster. Wenn Sie vergessen diese Datei in ein XUL-Fensterer einzubinden, führt das normalerweise zu intersanten und oft ungewohlten Ergebnissen. In unserem Fall müssen wir diese nicht einbinden, seit wir die Hauptbrowser-XUL-Datei überblenden und diese bindet bereits diese globale CSS-Datei ein. Auf jeden Fall ist es besser sie immer einzubinden. Auf diesem Weg ist es schwieriger Fehler durch ein nicht einbinden zu vermeiden. Sie können den Chrome-Pfad in der Adressleiste eingeben und überprüfen wenn Sie sich unsicher sind.</p>

<p>Dies behandelt alle Dateien der Hello World-Erweiterung. Nun sollten Sie eine Idee haben welche in die Erweiterungsentwicklung involviert sind, nun steigen wir direkt ein und stzen eine Eintwicklungumgebung auf. Aber als erstes eine kleine Übung.</p>

<p>This covers all of the files in the Hello World extension. Now you should have an idea of the basics involved in extension development, so now we'll jump right in and set up a development environment. But first, a little exercise.</p>

<h2 id="Übung">Übung</h2>

<p>Mache die folgenden Änderungen in der Beispielerweiterung:</p>

<ul>
 <li>Passe die Willkommensmeldung die im Benachrichtigungsfenster angezeigt wird an.</li>
 <li>Verschiebe das Hello World -menü in das Extras -menü.</li>
</ul>

<p>Packe die XPI neu. Führe unter Linux oder Mac OS X folgendes Kommando innerhalb des Wurzelverzeichnisses der Erweiterung aus:</p>

<pre>zip -r ../xulschoolhello2.xpi *
</pre>

<p>Verwende unter Windows ein ZIP-Tool um alle Datei und Unterverzeichnisse innerhalb des Wurzelverzeichnisses der Erweiterung zu packen und setze die Dateierweiterung der Datei auf .xpi.</p>

<p>Installiere die XPI neu. Sie können hierzu die XPI-Datei hierzu einfach in den Browser ziehen und diese wird lokal installiert.</p>

<p>Teste es und überprüfe ob die Änderungen funktionieren. Wenn Sie auf Probleme während der Installation stoßen, ist es wahrscheinlich, dass Sie die XPI-Struktur nicht korrekt nachgebildet haben, möglicherweise durch das hinzufügen unnötiger Ordner.</p>

<div class="note"><strong>Note:</strong> Packaging an extension is really just creating a ZIP archive of the contents of the main folder, then changing the filename extension to <code>.XPI</code>. Do <strong>not</strong> zip the containing folder, just its contents. The <code>content</code> folder, <code>chrome.manifest</code>, <code>install.rdf</code>, and other files and directories should be at the root level of your archive. If you zip the containing folder, your extension will not load.</div>

<p>Beachte, dass das Extramenü standardmäßig in Firefox 4und höher, unter Windows und einige Linuxdistributionen versteckt ist. Setze einen Hacken im Optionsmenü unter dem Firefoxmenüknopf um es zu aktivieren.</p>

<p>Nachdem Sie fertig sind, können Sie sich diese Refernzlösung ansehen: <a href="/@api/deki/files/5141/=xulschoolhello2.xpi" title="https://developer.mozilla.org/@api/deki/files/5141/=xulschoolhello2.xpi">Hello World 2</a>.</p>

<p><img alt="" src="https://mdn.mozillademos.org/files/8423/menu_item%20-%20helloworld2.png"></p>

<p>{{ PreviousNext("XUL_School/Getting_Started_with_Firefox_Extensions", "XUL_School/Setting_Up_a_Development_Environment") }}</p>

<p><span style="font-size: small;">This tutorial was kindly donated to Mozilla by Appcoast.</span></p>
