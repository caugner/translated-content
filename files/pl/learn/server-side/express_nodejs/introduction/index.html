---
title: Wprowadzenie do Express/Node
slug: Learn/Server-side/Express_Nodejs/Introduction
tags:
  - Początkujacy Express Node
translation_of: Learn/Server-side/Express_Nodejs/Introduction
---
<div>{{LearnSidebar}}</div>

<div>{{NextMenu("Learn/Server-side/Express_Nodejs/development_environment", "Learn/Server-side/Express_Nodejs")}}</div>

<dl>
 <dd>Znajdziesz tutaj odpowiedzi na pytania "Czym jest Node?" i "Co to jest Express?", oraz zrozumiesz co czyni framework Express wyjątkowym. W dalszej części zostały przedstawione najistotniejsze możliwości wraz z głównymi elementami potrzebnymi do budowy aplikacji webowych w Express (choć jeszcze nie będziesz miał przygotowanego środowiska do tworzenia i testowania takich aplikacji).</dd>
</dl>

<table class="learn-box standard-table">
 <tbody>
  <tr>
   <th scope="row">Wymagania:</th>
   <td>Podstawowe umiejętności w posługiwaniu się komputerem. Rozumienie ogólnych zasad <a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/First_steps">programowania po stronie serwera</a>,  w szczególności mechanizmów <a href="/en-US/docs/Learn/Server-side/First_steps/Client-Server_overview">interakcji między klientem a serwerem aplikacji webowych</a>.</td>
  </tr>
  <tr>
   <th scope="row">Cel:</th>
   <td>Zapoznanie się z frameworkiem Express, jego współpracą ze środowiskiem Node, jego funkcjonalnością i głównymi elementami aplikacji tworzonymi w tym frameworku.</td>
  </tr>
 </tbody>
</table>

<h2 id="Wprowadzenie_do_Node">Wprowadzenie do Node</h2>

<p><a href="https://nodejs.org/">Node</a> (lub bardziej formalnie <em>Node.js</em>) jest wieloplatformowym oprogramowaniem o otwartym kodzie, które pozwala deweloperom na tworzenie wszelkiego rodzaju oprogramowania w języku JavaScript pracującym po stronie serwera. Jest to środowisko uruchomieniowe, które działa poza przeglądarką, współpracujące bezpośrednio z systemem operacyjnym. W ten sposób środowisko Node udostępnia swoim aplikacjom API systemu operacyjnego, w tym dostęp do systemu plików, bibliotek systemowych czy uruchomionych procesów, w tym serwerów HTTP.</p>

<p>Z perspektywy tworzenia oprogramowania po stronie serwera, Node ma szereg zalet:</p>

<ul>
 <li>Wysoka wydajność! Node zostało zaprojektowane, aby optymalizować wydajność i skalowalność aplikacji webowych i jest dobrym rozwiązaniem wielu często występujących problemów podczas tworzenia aplikacji tego typu.</li>
 <li>Kod aplikacji to "stary dobry JavaScript", co oznacza, że spędzamy mniej czasu na "przełączanie kontekstu" podczas pracy z różnymi językami po stronie klienta i serwera.</li>
 <li>JavaScript jest relatywnie nowym językiem programowania i oferuje sporo ulepszeń w porównaniu do innych, tradycyjnie używanych po stronie serwera języków (np. PHP, Python itd.). Także wiele nowszych i popularnych języków jest kompilowanych/tłumaczonych do JavaScript, więc możesz korzystać także z TypeScript, CoffeScript, ClojureScript, Scala.js, LiveScript i innych.</li>
 <li>Menadżer pakietów środowiska Node (NPM - Node Package Manager) daje Ci dostęp do setek tysięcy pakietów, z których możesz korzystać. Posiada on najlepszy w swojej klasie mechanizm rozwiązywania zależności i może być wykorzystany do automatyzacji pracy narzędzi budujących aplikację.</li>
 <li>Node.js jest przenośne. Jest dostępne dla Microsoft Widnows, macOs, Linux, Solaris, FreeBSD, OpenBSD, WebOS, and NonStop OS. Jest także wspierane przez dostawców usług sieciowych, którzy zapewniają odpowiednią infrastrukturę i dokumentację do hostowania aplikacji Node.</li>
 <li><span style="font-size: 1rem; letter-spacing: -0.00278rem;">Ma też bardzo aktywny ekosystem firm trzecich i społeczność programistów, którzy gotowi są służyć pomocą.</span></li>
</ul>

<p>Możesz teraz wykorzystać Node.js do stworzenia prostego serwera stron WWW posługując się pakietem HTTP.</p>

<h3 id="Hello_Node.js">Hello Node.js</h3>

<p>W poniższym przykładzie utworzymy serwer WWW, który będzie oczekiwał dowolnego rodzaju żądań HTTP skierowanych pod URL <code>http://127.0.0.1:8000/</code> - gdy żądanie zostanie odebrane, skrypt wyśle odpowiedź z łańcuchem "Hello World". Jeśli masz już zainstalowane Node, możesz wykonać poniższe kroki, aby wykonać przykład:</p>

<ol>
 <li>Otwórz terminal (w Windows otwórz wiersz poleceń - cmd.exe).</li>
 <li>Utwórz katalog w miejscu, którym chcesz zapisać program, na przykład <code>test-node</code>, a następnie wejdź do nie niego wykonując polecenie w terminalu:</li>
</ol>

<pre>cd test-node</pre>

<ol start="3">
 <li>Korzystając z ulubionego edytora tekstu, utwórz plik o nazwie <code>hello.js</code> i wklej do niego poniższy kod:</li>
</ol>

<pre class="brush: js">// Load HTTP module
const http = require("http");

const hostname = "127.0.0.1";
const port = 8000;

// Create HTTP server
const server = http.createServer((req, res) =&gt; {

   // Set the response HTTP header with HTTP status and Content type
   res.writeHead(200, {'Content-Type': 'text/plain'});

   // Send the response body "Hello World"
   res.end('Hello World\n');
});

// Prints a log once the server starts listening
server.listen(port, hostname, () =&gt; {
   console.log(`Server running at http://${hostname}:${port}/`);
})
</pre>

<ol start="4">
 <li>Zapisz plik do katalogu, który utworzyłeś powyżej w punkcie 2.</li>
 <li>Wróć do terminalu i wpisz następujące polecenie:</li>
</ol>

<pre class="brush: bash">node hello.js</pre>

<p>W ostatnim kroku otwórz przeglądarkę WWW i wpisz adres <code>http://localhost:8000</code> ; powinieneś zobaczyć napis "<strong>Hello World</strong>" w lewy górnym rogu pustej strony.</p>

<h2 id="Frameworki_do_budowy_aplikacji_webowych">Frameworki do budowy aplikacji webowych</h2>

<p>Inne typowe zadania związane z tworzeniem aplikacji internetowych nie są bezpośrednio wspierane przez samo Node.js. Jeśli chcesz obsługiwać osobno każdą z metod HTTP (np. GET, POST, DELETE itp.), lub obsługiwać żądania w różnych ścieżkach URL („routes”), lub wysyłać statyczne dokumenty (jako pliki HTML) lub korzystać z szablonów do dynamicznego tworzenia odpowiedzi, to będziesz musiał napisać kod samemu. Albo zamiast wymyślać na nowo koło możesz użyć frameworka webowego do tworzenia aplikacji!</p>

<h2 id="Wprowadzenie_do_Express">Wprowadzenie do Express</h2>

<p><a href="https://expressjs.com/">Express</a> to jeden z najpopularniejszych frameworków webowych, który jest także wykorzystywany jako biblioteka w wielu innych popularnych <a href="https://expressjs.com/en/resources/frameworks.html">frameworkach Node</a>. Dostarcza następujących mechanizmów:</p>

<ul>
 <li>Tworzenie funkcji obsługujących żądania o różnych metodach HTTP i skierowanych do różnych ścieżek w URL (tzw. routing).</li>
 <li>Integrację z różnymi silnikami do generowania widoków, które są tworzone na podstawie osadzanych danych w szablonach stron.</li>
 <li>Konfigurowania typowych ustawień aplikacji webowych jak np. portu, lokalizacji szablonów do generowania widoków odpowiedzi.</li>
 <li>Dodatkowe przetwarzanie żądań w warstwie pośredniej (tzw. "middleware"), które może być umieszczone w dowolnym miejscu łańcucha obsługi żądania.</li>
</ul>

<p>Ponieważ <em>Express </em>jest dość minimalistyczny, dlatego deweloperzy stworzyli wiele kompatybilnych z nim pakietów pracujących w warstwie pośredniej, które rozwiązują prawie każdy problem pojawiający się w aplikacjach webowych. Są dostępne biblioteki do zarządzania ciasteczkami, do pracy w trybie sesji, do logowania użytkowników, do parsowania: parametrów w URL, danych przesyłanych w żądaniach POST, nagłówków zabezpieczeń i wiele innych. Pełną listę bibliotek rozwijanych przez zespół programistów Express znajdziesz na stronie <a href="http://expressjs.com/en/resources/middleware.html">Express Middleware</a> (która zawiera także popularne pakiety firm trzecich).</p>

<div class="note">
<p><strong>Uwaga:</strong>  Ta elastyczność Express ma dwa różne oblicza. Jest wiele  pakietów warstwy pośredniej, które rozwiązują prawie każdy problem lub wymaganie, ale ich opracowanie jest czasem nie lada wyzwaniem. Nie ma także "jedynie słusznej" struktury aplikacji, wiele dostępnych w Internecie przykładów nie jest optymalnych, lub prezentują tylko niewielki wycinek tego, co musisz zrobić, aby zbudować aplikację webową.</p>
</div>

<h2 id="Skąd_się_wziął_Node_i_Express">Skąd się wziął Node i Express?</h2>

<p>Pierwsza edycja Node została wydana, tylko dla systemu Linux, w 2009 roku. Menadżer pakietów NPM pojawił się w 2010, a natywne wsparcie dla systemu Windows dodano w 2012 roku. Bieżąca edycja LTS Node ma wersję v12.13.1, gdy najnowsza wersja Node ma numer 13.2.0. Jest to tylko krótki wycinek z bogatej historii; jeśli chcesz się więcej dowiedzieć zajrzyj do <a href="https://en.wikipedia.org/wiki/Node.js#History">Wikipedi</a>i.</p>

<p>Express został pierwotnie wydany w listopadzie 2010 i obecnie jest dostępny w wersji 4.17.1. Możesz sprawdzić <a href="https://expressjs.com/en/changelog/4x.html">dziennik zmian</a>, aby uzyskać informacje o zmianach w bieżącej wersji, a <a href="https://github.com/expressjs/express/blob/master/History.md">GitHub</a>, aby uzyskać bardziej szczegółowe informacje o historii wersji.</p>

<h2 id="Jak_popularne_są_Node_i_Express">Jak popularne są Node i Express?</h2>

<p>Popularność danego frameworku jest bardzo ważna, gdyż jest wskaźnikiem, czy będzie rozwijany i nadal będzie dostępna dokumentacja, dodatkowe biblioteki i wsparcie techniczne.</p>

<p>Oczywiście nie ma miarodajnego wskaźnika popularności frameworków po stronie serwera (choć są strony takie jak <a href="http://hotframeworks.com/">Hot Frameworks</a>, które próbują oszacować popularność danego framworku na podstawie liczby projektów na GitHub i liczby pytań w serwisie StackOverflow). Lepszym pytaniem jest to, czy Node i Express są wystarczająco popularne, aby nie spotkał ich los niszowych lub zapomnianych platform. Czy mogą liczyć na dalszy rozwój. Czy możesz liczyć na pomoc, gdy będziesz jej potrzebował? Czy istniej możliwość dostania pracy jeśli nauczysz się platformy Express.</p>

<p>Opierając się na liczbie znanych firm korzystających z Express, liczbie osób wnoszących wkład w kod źródłowy oraz liczbie osób zapewniających zarówno bezpłatne, jak i płatne wsparcie, można potwierdzić, że Express jest popularnym frameworkiem!</p>

<h2 id="Czy_Express_jest_restrykcyjny">Czy Express jest restrykcyjny?</h2>

<p>Frameworki webowe często określają siebie jako restrykcyjne lub elastyczne.</p>

<p>Frameworki restrykcyjne to takie, które prezentują jeden „właściwy sposób” na wykonanie określonego zadania. Najczęściej wspierają szybki rozwój w określonej dziedzinie (rozwiązywanie problemów określonego typu), ponieważ ten właściwy sposób realizacji zadania jest zwykle dobrze rozpoznany i udokumentowany. Są jednak znaczniej mniej elastyczne w rozwiązywaniu problemów poza obszarem swojej głównej domeny i nie oferują dużych możliwości w kwestii wyboru komponentów czy rozwiązań, których można użyć.</p>

<p>Przeciwieństwem są frameworki elastyczne, które mają znacznie mniejsze ograniczenia dotyczące wyboru połączenia komponentów w celu realizacji aplikacji, a nawet tego, które komponenty należy zastosować. Ułatwiają programistom na korzystanie z najodpowiedniejszych dla nich narzędzi do wykonania określonego zadania, aczkolwiek kosztem jest konieczność samodzielnego szukania takich komponentów.</p>

<p>Express jest elastyczny. Możesz korzystać z dowolnego kompatybilnego oprogramowania w warstwie pośredniej, włączając je w dowolnym miejscu całego łańcucha obsługi żądań. Możesz tworzyć aplikację z kodem w jednym pliku lub podzielić kod na wiele plików, korzystając z dowolnej struktury katalogów. Czasami możesz odnieść wrażenie, że masz zbyt wiele możliwości!</p>

<h2 id="Jak_wygląda_kod_Express">Jak wygląda kod Express?</h2>

<p>Tradycyjna aplikacja webowa przetwarzająca dane czeka na żądania HTTP nadchodzące z przeglądarki (lub innego programu klienta). W chwili, gdy żądanie nadejdzie, aplikacja określa akcję, która musi być podjęta. O tym jaką akcję należy wybrać decydują wzorzec zawarty w URL i ewentualne informacje zawarte w żądaniu POST lub GET. W zależności od żądania aplikacja może odczytać lub zapisać informacje w bazie danych, może też wykonywać inne zadania. Gdy aplikacja zakończy akcję wysyła odpowiedź do przeglądarki klienta. Najczęściej tą odpowiedzią jest dynamicznie tworzony dokument HTML zawierający dane dla przeglądarki klienta. Dokument taki tworzony jest na podstawie szablonu HTML, w którym wyróżnione są miejsca na dane.</p>

<p>W kolejnych sekcjach wyjaśnimy typowe elementy kodu, z którymi się spotkasz podczas pracy z Express i Node.</p>

<h3 id="Hello_World_Express">Hello World Express</h3>

<p>Na początek zajmiemy się nieśmiertelnym przykładem <a href="https://expressjs.com/en/starter/hello-world.html">Hello World</a> (przedyskutujemy każdy fragment kou w tej i następnych sekcjach).</p>

<div class="note">
<p><strong>Wskazówka: </strong>Jeśli już masz zainstalowany Node i Express (lub zainstalujesz oba według wskazówek zawartych w <a href="/en-US/docs/Learn/Server-side/Express_Nodejs/development_environment">następnym artykule</a>), zapisz poniższy kod w pliku <strong>app.js</strong> a następnie uruchom go wpisując w wierszu poleceń:</p>

<p><strong><code>node ./app.js</code></strong></p>
</div>

<pre class="brush: js">var express = require('express');
var app = express();

<strong>app.get('/', function(req, res) {
  res.send('Hello World!');
});</strong>

app.listen(3000, function() {
  console.log('Example app listening on port 3000!');
});
</pre>

<p>W pierwszych dwóch wierszach importujemy przez <code>require()</code> moduł o nazwie express a następnie tworzymy <a href="https://expressjs.com/en/4x/api.html#app">Aplikację Express</a>. Zwyczajowo obiekt aplikacji został nazwany <code>app</code> i zawiera metody do ustalania trasy (routing) żądań, konfiguracji warstwy pośredniej, renderowania widoków w HTML, rejestracji silnika szablonów i konfiguracji <a href="https://expressjs.com/en/4x/api.html#app.settings.table">ustawień aplikacji</a>, które kontrolują jej zachowanie (np. tryb środowiska, czy definicje routingu są wrażliwe na wielkość znaków itd.)</p>

<p>W środkowej części kodu (trzy kolejne wiersze zaczynające  się od <code>app.get</code>) znajduje się definicja trasy. Metoda określa funkcję zwrotną, która zostanie wywołana, gdy pojawi się żądanie GET HTTP skierowane do ścieżki (<code>'/'</code>) względem katalogu głównego strony. Argumentami funkcji zwrotnej są obiekty żądania (request) i odpowiedzi (response). W ciele funkcji została wywołana metoda <code><a href="https://expressjs.com/en/4x/api.html#res.send">send()</a></code>  odpowiedzi, która wysyła napis "Hello World!" do klienta.</p>

<p>Ostatni blok odpowiada za uruchomienie serwera, który nasłuchuje na porcie 3000 i drukuje komunikaty logów na konsoli. Gdy serwer już działa możesz otworzyć przeglądarkę i po wpisaniu adresu <code>localhost:3000</code> powinieneś zobaczyć odpowiedź serwera.</p>

<h3 id="Import_i_tworzenie_modułów">Import i tworzenie modułów</h3>

<p>Modułem jest biblioteka lub plik JavaScript, który można zaimportować do innego pliku źródłowego przy użyciu funkcji <code>require()</code>. <em>Express </em>jest też modułem, podobnie jak biblioteki funkcji warstwy pośredniej czy baz danych.</p>

<p>W kodzie poniżej widać, jak importujemy moduł przez nazwę, podobnie jak zaimportowaliśmy framework <em>Exress</em> w przykładzie. Najpierw wywołujemy funkcję <code style="font-style: normal; font-weight: normal;">require() </code>z podaną nazwą modułu (<code>'express'</code>), a potem wykorzystujemy zwrócony przez import obiekt, żeby utworzyć <a href="https://expressjs.com/en/4x/api.html#app">aplikację Express</a>. Mając obiekt aplikacji możemy korzystać z jego właściwości i metod.</p>

<pre class="brush: js">var express = require('express');
var app = express();
</pre>

<p>Oczywiście możesz też tworzyć własne moduły, które moga być importowane w ten sam sposób.</p>

<div class="note">
<p><strong>Wskazówka:</strong>  Dobrze, żebyś tworzył własne moduły, wtedy Twoja aplikacja będzia złożona z osobnych, łatwo zarządzanych części. Trzymanie całego kodu aplikacji w jednym pliku tworzy trudny do utrzymania i zrozumienia monolit. Korzystanie z modułów pomoże Ci w kontrolowaniu przestrzeni nazw, czyli na zewnątrz modułu będą dostępne tylko te zmienne, które jawnie z niego eksportujesz.</p>
</div>

<p>Obiekty, które mają być dostępne na zewnątrz modułu, muszą być przez Ciebie wskazane za pomocą dodanej właściwości obiektu <code>exports</code>. Przykładowy poniżej moduł, zapisany w pliku <strong>square.js</strong>, exportuje dwie metody: <code>area()</code> i <code>perimeter()</code>. </p>

<pre class="brush: js">exports.area = function(width) { return width * width; };
exports.perimeter = function(width) { return 4 * width; };
</pre>

<p>Możemy zaimportować moduł funkcją <code>require()</code> i wywołać wyeksportowane metody:</p>

<pre class="brush: js">var square = require('./square'); // Here we require() the name of the file without the (optional) .js file extension
console.log('The area of a square with a width of 4 is ' + square.area(4));</pre>

<div class="note">
<p><strong>Wskazówka:</strong>  Możesz też wskazać moduł podając ścieżkę absolutną do jego pliku (lub nazwy, tak jak to już robiliśmy).</p>
</div>

<p>Jeśli chcesz wyeksportować cały obiekt jednym przypisaniem (zamiast eksportować osobno każdą jego metodę lub pole) to przypisz ten obiekt do <code>module.exports</code> (możesz również tak zrobić, aby obiekt główny eksportu był konstruktorem lub inną funkcją):</p>

<pre class="brush: js">module.exports = {
  area: function(width) {
    return width * width;
  },

  perimeter: function(width) {
    return 4 * width;
  }
};
</pre>

<div class="note">
<p><strong>Wskazówka:</strong>  Możesz traktować  <code>exports</code> jak <a href="https://nodejs.org/api/modules.html#modules_exports_shortcut">skrót</a> do <code>module.exports</code> w obrębie danego modułu. Faktycznie, <code>exports</code>  jest właśnie zmienną zainicjalizowana  wartością <code>module.exports</code> zanim modułe zostanie ewaluowany. Ta wartość jest referencją do obiektu (w tym przypadku pustego). Oznacza to, że <code>exports</code> przechowuje referencję do tego samego obiektu, którego odwołuje się <code>module.exports</code>.  To oznacza także, że przypisując do obiektu <code>exports</code> inną wartość przestaje on mieć związek z <code>module.exports</code>.</p>
</div>

<p>Więcej informacji o modułach znajdziesz w dokumentacji API Node: <a href="https://nodejs.org/api/modules.html#modules_modules">Modules</a>.</p>

<h3 id="Asynchroniczne_API">Asynchroniczne API</h3>

<p>Kod JavaScript częściej wykorzystuje asynchroniczne wykonywanie operacji, których czas może być znaczny. Synchroniczne wykonywanie kodu zakłada, że następna operacja nie może się zacząć, dopóki poprzednia się nie zakończy. Przykładem może być wywołanie synchroniczne dwóch funkcji wysyłających komunikaty do konsoli, które powinny się wyświetlić w kolejności: "First, Second":</p>

<pre class="brush: js">console.log('First');
console.log('Second');
</pre>

<p>Przeciwieństwem jest kod wykonywany asynchronicznie, w którym kolejna operacja jest uruchamiana, i zanim się zakończy, wywołana jest następna. Gdy operacja się zakończy, mechanizm API wywołuje dodatkowe działanie. Poniższy przykład wyświetli na konsoli komunikaty "Second, First", ponieważ najpierw wywoływana jest funkcja <code>setTimeout()</code>, która po uruchomieniu odliczania czasu, natychmiast wraca i jest wywoływana następna funkcja.</p>

<pre class="brush: js">setTimeout(function() {
   console.log('First');
   }, 3000);
console.log('Second');
</pre>

<p>Korzystanie z nieblokującego asynchronicznego API jest znacznie ważniejsze w Node niż w przeglądarce, ponieważ Node jest jednowątkowym, sterowanym zdarzeniowo, środowiskiem uruchomieniowym. "Jednowątkowe" oznacza, że wszystkie żądania skierowane do serwera są wykonywane w tym samym wątku (czyli nie są uruchamiane w oddzielnych procesach, które mogłyby się wykonywać równocześnie). Taki model jest bardzo wydajny pod względem szybkość wykonywania i wykorzystania zasobów serwera, ale powoduje on, że jeśli zostanie wywołana synchronicznie funkcja, której wykonanie trwa długo, to zablokuje ona nie tylko bieżące żądanie, ale także wszystkie pozostałe obsługiwane w tym czasie przez aplikację.</p>

<p>Jest kilka metod do sygnalizowania, że asynchroniczna operacja się zakończyła. Najczęściej wykorzystywana jest rejestracja funkcji zwrotnej podczas wywoływania asynchronicznego. Funkcja zwrotna zostanie wywołana, gdy asynchroniczna operacja się zakończy. Z takiego podejścia skorzystano w przykładzie powyżej.</p>

<div class="note">
<p><strong>Uwaga:</strong> Korzystanie z funkcji zwrotnych może prowadzić do bałaganu. Jeśli zaczniesz tworzyć sekwencję kolejnych wywołań operacji asynchronicznych, aby wykonały się we właściwym porządku, to w rezultacie powstaje wiele poziomów zagnieżdżonych wywołań. Jest to znany problem o nazwie "callback hell" (piekło funkcji callback).  Skutki problemu można złagodzić stosując dobre praktyki (zobacz <a href="http://callbackhell.com/">http://callbackhell.com/</a>), wykorzystując odpowiednie biblioteki jak np. <a href="https://www.npmjs.com/package/async">async</a>, lub możliwości standardu ES6 jak np. <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises</a>.</p>
</div>

<div class="note">
<p><strong>Uwaga:</strong>  Funkcje zwrotne w Node i Express stosują wspólną konwencję, według której pierwszym argumentem funkcji zwrotnej jest wartość błędu. Drugim argumentem jest obiekt zawierający wszystkie dane zwrócone po prawidłowym zakończeniu funkcji wywołującej. Blog <a href="http://fredkschott.com/post/2014/03/understanding-error-first-callbacks-in-node-js" style="font-size: 1rem; letter-spacing: -0.00278rem;">The Node.js Way - Understanding Error-First Callbacks</a><span style="font-size: 1rem; letter-spacing: -0.00278rem;"> (fredkschott.com) zawiera dobre wyjaśnienie, dlaczego ta konwencja jest tak użyteczna</span><span style="font-size: 1rem; letter-spacing: -0.00278rem;">.</span></p>
</div>

<h3 id="Tworzenie_procedur_obsługi_tras">Tworzenie procedur obsługi tras</h3>

<p>W naszej przykładowej aplikacji Hello World zdefiniowaliśmy funkcję obsługującą żądania GET protokołu HTTP skierowane do katalogu głównego strony <code>'/'</code>).</p>

<pre class="brush: js">app.<strong>get</strong>('/', function(req, res) {
  res.send('Hello World!');
});
</pre>

<p>Funkcja zwrotna podczas wywołania otrzymuje obiekty żądania i odpowiedzi jako argumenty. W naszym przypadku funkcja po prostu wywołuje <code><a href="https://expressjs.com/en/4x/api.html#res.send">send()</a></code> na obiekcie odpowiedzi ,żeby wysłać napis "Hello World!". Nie jest to jedyna metoda formułowania odpowiedzi na żądanie. Istnieje wiele metod kończących cykl procesu przetwarzania żądania w odpowiedzi np. możesz wywołać metodę <code><a href="https://expressjs.com/en/4x/api.html#res.json">json()</a></code>, żeby wysłać odpowiedź w formacie JSON lub <code><a href="https://expressjs.com/en/4x/api.html#res.sendFile">sendFile()</a></code>, aby wysyłać plik.</p>

<div class="note">
<p><strong>JavaScript tip:</strong>  W funkcji zwrotnej obiekty żądania i odpowiedzi mogą mieć dowolne nazwy, ważne abyś zapamiętał, że podczas wywołania tej funkcji zawsze pierwszym argumentem jest obiekt żądania, a drugim obiekt odpowiedzi. Jednak jest głęboki sens w tym, aby oba argumenty nazwać zgodnie z ich przeznaczeniem.</p>
</div>

<p>Obiekt aplikacji Express posiada odpowiednie metody do definiowania funkcji obsługujących pozostałe rodzaje żądań HTTP :</p>

<p><code>checkout()</code>, <code>copy()</code>, <strong><code>delete()</code></strong>, <strong><code>get()</code></strong>, <code>head()</code>, <code>lock()</code>, <code>merge()</code>, <code>mkactivity()</code>, <code>mkcol()</code>, <code>move()</code>, <code>m-search()</code>, <code>notify()</code>, <code>options()</code>, <code>patch()</code>, <strong><code>post()</code></strong>, <code>purge()</code>, <strong><code>put()</code></strong>, <code>report()</code>, <code>search()</code>, <code>subscribe()</code>, <code>trace()</code>, <code>unlock()</code>, <code>unsubscribe()</code>.</p>

<p>Jest  też jedna specjalna metoda <code>app.all()</code>, która jest wywoływana dla każdego żądania HTTP. Wykorzystuje się ją do instalowania funkcji warstwy pośredniej obsługujących wybraną trasę dla dowolnych żądań. Poniższy przykład (pochodzący z dokumentacji Express) ilustruje przypadek funkcji obsługującej wszystkie żądania (o dowolnej metodzie HTTP) skierowane do ścieżki  <code>/secret</code> (funkcja pochodzi z modułu <a href="https://nodejs.org/api/http.html#http_http_methods">http</a>).</p>

<pre class="brush: js">app.all('/secret', function(req, res, next) {
  console.log('Accessing the secret section ...');
  next(); // pass control to the next handler
});</pre>

<p>Metody definiujące trasy są wywoływane na podstawie dopasowania do określonych wzorców w URL jak i wydobywają pewne części z URL i przekazują je jako parametry do funkcji obsługi żądania (jako atrybuty żądania).</p>

<p>Często przydatne jest grupowanie procedur obsługi tras dla określonej części witryny i uzyskiwanie do nich dostępu za pomocą wspólnego przedrostka ścieżki (np. strona z Wiki może mieć wszystkie trasy związane z wiki w jednym pliku i mieć do nich dostęp w postaci ścieżki z prefiksem /wiki/). Za realizacje grupowania odpowiedzialny jest obiekt <code><a href="http://expressjs.com/en/guide/routing.html#express-router">express.Router</a></code>.  Wracając do przykładu Wiki: wszystkie trasy możemy umieścić w module <strong>wiki.js</strong> i wyeksportować je do obiektu <code>Router</code> , jak w przykładzie poniżej:</p>

<pre class="brush: js">// wiki.js - Wiki route module

var express = require('express');
var router = express.Router();

// Home page route
router.get('/', function(req, res) {
  res.send('Wiki home page');
});

// About page route
router.get('/about', function(req, res) {
  res.send('About this wiki');
});

module.exports = router;
</pre>

<div class="note">
<p><strong>Uwaga:</strong> Dodawanie tras do obiektu <code>Router</code> jest jak dodawanie tras do obiektu <code>app</code> (jak pokazaliśmy to już wcześniej).</p>
</div>

<p>Dołączamy utworzony router (nasz plik <strong>wiki.js</strong>) do głównego pliku aplikacji przez <code>require()</code>  i włączamy go do warstwy pośredniej aplikacji wywołując metodę <code>use()</code>. To spowoduje, że nasza aplikacja będzie teraz obsługiwać dwie ściezki: <code style="font-style: normal; font-weight: normal;">/wiki/</code> i <code style="font-style: normal; font-weight: normal;">/wiki/about/</code>.</p>

<pre class="brush: js">var wiki = require('./wiki.js');
// ...
app.use('/wiki', wiki);</pre>

<p>W dalszych częściach cyklu pokażemy więcej możliwości konfigurowania ścieżek, w szczególności korzystanie z obiektu  <code>Router</code> w rozdziale <a href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/routes">Routery i kontrolery.</a></p>

<h3 id="Warstwa_pośrednia">Warstwa pośrednia</h3>

<p>Warstwa pośrednia (middleware) jest bardzo istotną częścią aplikacji Express. Wykonuje ona wiele operacji począwszy od obsługi plików statycznych po kompresje odpowiedzi HTTP. Jeśli funkcje obsługi żądań są ostatnim etapem, w którym wysyłamy odpowiedź do klienta, to funkcje middleware po wykonaniu operacji na żądaniu lub odpowiedzi wywołują następną funkcje w łańcuchu, którą może być kolejna funkcja warstwy pośredniej lub końcowa funkcja obsługi żądania. O kolejnością wywołań funkcji middleware decyduje programista.</p>

<div class="note">
<p><strong>Uwaga:</strong> Warstwa pośrednia może wykonywać dowolne operacje, wykonywać dowolny kod, dokonywać zmian w żądaniu lub odpowiedzi a także może zakończyć cały cykl przetwarzania żądania w odpowiedź. Jeśli funkcja middleware nie kończy przetwarzania to musi wywołać metodę <code>next()</code>, która przekazuje sterowanie do następnej funkcji warstwy (w przeciwnym przypadku żądanie zostanie zawieszone). </p>
</div>

<p>Większość aplikacji korzysta z funkcji warstwy pośredniej firm trzecich, bo upraszcza to proces projektowania aplikacji webowych, w których korzystamy z ciasteczek, sesji, autentykacji użytkowników, danych w formacie JSON, logowania itd. Lista dostępnych pakietów znajduje się na stronie <a href="http://expressjs.com/en/resources/middleware.html">Express middleware</a> (łącznie z pakietami firm trzecich). Więcej pakietów jest dostępnych poprzez menadżer pakietów NPM.</p>

<p>Pakiet middleware'u, który chcesz wykorzystać w swojej aplikacji, musisz najpierw zainstalować przy pomocy NPM. Załóżmy, że chcesz dodać logger żądań do warstwy pośredniej znajdujący się w pakiecie <a href="http://expressjs.com/en/resources/middleware/morgan.html">morgan</a> HTTP:</p>

<pre class="brush: bash"><code>$ npm install morgan
</code></pre>

<p>Teraz powinieneś go dodać do stosu warstwy pośredniej wywołując metodę <code>use()</code>:</p>

<pre class="brush: js">var express = require('express');
<strong>var logger = require('morgan');</strong>
var app = express();
<strong>app.use(logger('dev'));</strong>
...</pre>

<div class="note">
<p><strong>Uwaga:</strong> Funkcje middleware'u i obsługi żadań wywoływane są w kolejności ich deklaracji. Dla wybranych pakietów ich miejsce w łańcuchu wywołań jest bardzo ważne (np. jeśli warstwa sesji zależy od warstwy obsługi ciasteczek, wtedy funkcja obsługi ciasteczek powinna być dodana jako pierwsza). W praktyce prawie zawsze funkcje warstwy pośredniej są dodawane przed definicją funkcji obsługi tras, gdyż w przeciwnym razie obsługa żądań nie będzie miała dostępu do funkcji warstwy pośredniej.</p>
</div>

<p>Oczywiście możesz tworzyć własne funkcje warstwy pośredniej, i prawdopodobnie będziesz zmuszony do ich definiowania (jak choćby funkcje obsługi błędów). Jedyną różnicą między funkcjami middleware'u, a funkcjami obsługi żądań jest dodatkowy, trzeci argument funkcji warstwy pośredniej. Argument ten, zazwyczaj o nazwie <code>next</code>, jest funkcją, której wywołanie uruchamia następną funkcje warstwy pośredniej. Każda funkcja middleware'u musi wywołać ten argument, gdyż tego oczekuje kontrakt przetwarzania żądania i odpowiedzi w warstwie pośredniej i to je odróżnia od funkcji, które tego nie robią lub nie posiadają takiego argumentu, na których kończy się cykl życia żądania.</p>

<p>Wywołując metodę <code>app.use()</code> masz dwie możliwości włączania funkcji middleware'u do łańcucha przetwarzania żądania, określając czy funkcja ta obsługuje wszystkie żądania czy tylko o określonej metodzie protokołu HTTP (GET, POST itd.). Możesz też określić dla jakiś ścieżek funkcja ma działać, choć podanie ścieżki przy wowołaniu <code>app.use()</code> jest opcjonalne.</p>

<p>W przykładzie poniżej możesz zobaczyć jak należy dodawać funkcje middleware'u bez i ze ścieżką.</p>

<pre class="brush: js">var express = require('express');
var app = express();

// An example middleware function
var a_middleware_function = function(req, res, <em>next</em>) {
  // ... perform some operations
  next(); // Call next() so Express will call the next middleware function in the chain.
}

// Function added with use() for all routes and verbs
app.use(a_middleware_function);

// Function added with use() for a specific route
app.use('/someroute', a_middleware_function);

// A middleware function added for a specific HTTP verb and route
app.get('/', a_middleware_function);

app.listen(3000);</pre>

<div class="note">
<p><strong>Wskazówka JavaScript:</strong> W przykładzie powyżej najpierw zadeklarowaliśmy funkcję middleware'u a następnie dodaliśmy ją jako funkcję zwrotną. W poprzednich przykładach funkcję zwrotną definiowaliśmy w miejscu definiowania funkcji obsługi żądania. W JavaScript oba podejścia są poprawne. </p>
</div>

<p>Dokumentacja Express zawiera o wiele więcej informacji na temat wykorzystania i definiowania warstwy pośredniej w aplikacjach webowych.</p>

<h3 id="Obsługa_plików_statycznych">Obsługa plików statycznych</h3>

<p>Aby Twoja aplikacja mogła obsługiwać pliki umieszczone na serwerze, jak pliki graficzne, CSS czy JavaScript, musi posiadać w warstwie pośredniej odpowiednią funkcję. Na szczęście jest ona częścią Express (jest to jedyna dostarczana z pakietem Express funkcja middlewaru). Jeśli na przykład, chcesz aby aplikacja umożliwiała klientom pobieranie plików z katalogu '<strong>public</strong>' (pliki CSS, JavaScript, grafika), który znajduje się w katalogu aplikacji, umieść poniższy kod:</p>

<pre class="brush: js">app.use(express.static('public'));
</pre>

<p>Każdy plik z katalogu `public` jest teraz dostępny pod adresem URL z dołączoną na końcu nazwą tego pliku. Na przykład:</p>

<pre><code>http://localhost:3000/images/dog.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/about.html
</code></pre>

<p>Możesz wielokrotnie dodać funkcję <code>static()</code>, aby dodać więcej katalogów z zasobami statycznymi. Jeśli plik nie zostanie znaleziony przez jedną funkcję middleware'u to żądanie tego pliku zostanie przekazane do następnej funkcji tej warstwy (kolejność wywołań funkcji jest zogdna z kolejnościa ich deklaracji).</p>

<pre class="brush: js">app.use(express.static('public'));
app.use(express.static('media'));
</pre>

<p>Istnieje też możliwość tworzenia wirtualnych przedrostów w URL do zasobów statycznych, tak aby nie udostępniać ich pod tym samym adresem bazowym URL. W rezultacie zasoby będą dostępne jakby były w odrębnym katalogu. Posłużmy się kolejnym przykładem, w którym podamy ścieżkę montowania katalogu `public` pod przedrostkiem "/media"</p>

<pre class="brush: js">app.use('/media', express.static('public'));
</pre>

<p>Od tego momentu możesz dostać się do plików z katalogu <code>public</code> podając URL zakończony prefiksem  <code>/media</code> z umieszczoną za nim nazwą pliku:</p>

<pre><code>http://localhost:3000/media/images/dog.jpg
http://localhost:3000/media/video/cat.mp4
http://localhost:3000/media/cry.mp3</code>
</pre>

<p>Więcej dowiesz się zaglądając do rozdziału <a href="Serving static files in Express">Udostępnianie plików statycznych w Express</a>.</p>

<h3 id="Obsługa_błędów">Obsługa błędów</h3>

<p>Błędy mogą być obsługiwane przez jedną lub więcej specjalnych funkcji middleware'u, które muszą posiadać cztery argumenty (w odróżnieniu od pozostałych, trójargumentowych funkcji tej warstwy) <code>(err, req, res, next)</code>. Popatrzmy na przykład poniżej:</p>

<pre class="brush: js">app.use(function(err, req, res, next) {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
</pre>

<p>Funkcje obsługi błędów mogą zwracać odpowiedzi o dowolnej zawartości, ale muszą zostać dodane metodą <code>app.use()</code>  po wszystkich pozostałych funkcjach tej warstwy, aby zostały wywołane na końcu procesu przetwarzania żądania.</p>

<p>Express posiada wbudowany mechanizm obsługi wszelkich błędów mogących wystąpić w aplikacji. Ta domyślna obsługa znajduje się w warstwie pośredniej jako ostania funkcja tej warstwy. Jeśli wywołaniem <code>next()</code> przekażesz błąd do następnej funkcji, w której nic z tym błędem nie zrobisz, to zostanie on obsłużony przez domyślną funkcję, która wyśle do klienta opis błędu wraz z opisem śladu stosu.</p>

<div class="note">
<p><strong>Uwaga:</strong>  Śledzenie stosu nie jest włączone do środowiska produkcyjnego. Aby je włączyć w trybie produkcyjnym musisz ustawić zmienną środowiskową <code>NODE_ENV</code> o wartości '<code>production'</code>. </p>
</div>

<div class="note">
<p><strong>Uwaga:</strong> HTTP404  i pozostałe "błędy" kojarzone z kodem statusu nie są traktowane jako błędy. Jeśli chcesz je kontrolować to musisz dołączyć odpowiednią funkcję middleware'u. Więcej informacji znajdziesz w <a href="http://expressjs.com/en/starter/faq.html#how-do-i-handle-404-responses">FAQ</a>.</p>
</div>

<p>Więcje o obsłudze błędów możesz dowiedzieć się w <a href="http://expressjs.com/en/guide/error-handling.html">Error handling</a> (Dokumentacja Express).</p>

<h3 id="Korzystanie_z_baz_danych">Korzystanie z baz danych</h3>

<p>Aplikacja Express może korzystać z dowolnej bazy danych wspieranej przez środowisko Node (sam Express nie definiuje żadnych specjalnych zachowań ani wymagań odnośnie współpracy z bazami danych). Możliwa jest współpraca z wieloma silnikami BD, włączając takie jak PostgreSQL, MySQL, Redis, SQLite, MongoDB itd.</p>

<p>Pierwszym krokiem jest zainstalowanie sterownika przy pomocy menadżera pakietów NPM. Na przykład zainstalowanie sterownika do popularnej bazy NoSQL MongoDB sprowadza się do wydania polecenia:</p>

<pre class="brush: bash"><code>$ npm install mongodb
</code></pre>

<p>Silnik bazodanowy może być zainstalowany lokalnie lub na zdalnym serwerze. W kodzie aplikacji wymagany jest zainstalowany sterownik, przy pomocy którego łączymy się z bazą i wykonujemy typowe operacje jak tworzenie, odczyt, edycja i usunięcie (CRUD). W przykładzie poniżej (dokumentacja Express) możesz zobaczyć jak znaleźć i odczytać wszystkie ssaki z bazy zawierającej informacje o zwierzętach.</p>

<pre class="brush: js">//this works with older versions of  mongodb version ~ 2.2.33
var MongoClient = require('mongodb').MongoClient;

MongoClient.connect('mongodb://localhost:27017/animals', function(err, db) {
  if (err) throw err;

  db.collection('mammals').find().toArray(function (err, result) {
    if (err) throw err;

    console.log(result);
  });
});


//for mongodb version 3.0 and up
let MongoClient = require('mongodb').MongoClient;
MongoClient.connect('mongodb://localhost:27017/animals', function(err, client){
   if(err) throw err;
   let db = client.db('animals');
   db.collection('mammals').find().toArray(function(err, result){
     if(err) throw err;
     console.log(result);
     client.close();
   });
});
</pre>

<p>Innym, popularnym modelem współpracy aplikacji z bazą danych jest ORM (Object Relational Mapping - mapowanie obiektowo relacyjne). Korzystanie z ORM powoduje, że dane utrwalane w bazie definiujemy jako obiekty lub modele, które są automatycznie mapowane na format bazodanowy. Zaletą takiego podejścia, jest to, że możesz myśleć w kategoriach obiektów JavaScript a nie formatu danych bazy, które w dodatku podlegają sprawdzeniu poprawności danych. Bardziej szczegółowo bazy danych omówimy w późniejszym artykule.</p>

<p>Więcej informacji znajdziesz w <a href="https://expressjs.com/en/guide/database-integration.html">Database integration</a> (Dokumentacja Express).</p>

<h3 id="Prezentacja_danych_widoki">Prezentacja danych (widoki)</h3>

<p>Silniki szablonów (określane w Express jako "view engines") pozwalają Ci na łatwiejsze tworzenie dokumentów wysyłanych jako odpowiedź żądania. Taki dokument, a jest to najczęściej plik HTML lub inny typ dokumentu, zawiera specjalne znaczniki, w miejscu których silnik szablonów wstawia, przekazane z funkcji obsługi żądania, dane. Express wspiera wiele różnych silników widoków, więc przy wyborze najbardziej odpowiedniego można posłużyć się zestawieniem <a href="https://strongloop.com/strongblog/compare-javascript-templates-jade-mustache-dust/">Comparing JavaScript Templating Engines: Jade, Mustache, Dust and More</a>.</p>

<p>Jeśli chcesz budować swoją aplikację w architekturze MVC musisz w niej wskazać położenie plików szablonów. W sekcji konfiguracyjnej aplikacji wskaż atrybutami 'views' lub 'view engine' katalog szablonów, tak jak poniżej:</p>

<pre class="brush: js">var express = require('express');
var app = express();

// Set directory to contain the templates ('views')
app.set('views', path.join(__dirname, 'views'));

// Set view engine to use, in this case 'some_template_engine_name'
app.set('view engine', 'some_template_engine_name');
</pre>

<p>Wygląd szablonu zależy od zastosowanego silnika generującego widoki, ale niezależnie od niego przekazanie danych do szablonu wygląda podobnie. Zakładając, że plik szablonu ma nazwę "index.&lt;template_extension&gt;", a w nim znajdują się znaczniki na umieszczenie zmiennych o nazwach `title` i `message`, to w funkcji obsługi żądania powinieneś wywołać <code><a href="http://expressjs.com/en/4x/api.html#res.render">Response.render()</a></code>, żeby klient otrzymał wygenerowany z szablonu dokument HTML:</p>

<pre class="brush: js">app.get('/', function(req, res) {
  res.render('index', { title: 'About dogs', message: 'Dogs rock!' });
});</pre>

<p>Więcej informacji o szablonach znajdziesz w <a href="http://expressjs.com/en/guide/using-template-engines.html">Using template engines with Express</a> (dokumentacja Express).</p>

<h3 id="Struktura_plików">Struktura plików</h3>

<p>Express nie wymaga sztywnej struktury plików, składających się na aplikację. Kontrolery, widoki, pliki statyczne i pozostałe elementy aplikacji mogą być rozmieszczone w dowolnej liczbie plików rozmieszczonych w dowolnej strukturze katalogów. Choć możliwe jest zawarcie całej aplikacji w jednym pliku, to znacznie bardziej rozsądnym rozwiązaniem jest podzielenie aplikacji na pliki o określonych funkcjach. (np. zarządzanie kontem, blogi, forum dyskusyjne) i zgodnie z architekturą aplikacji (np. model, widok i kontroler jeśli jest to aplikacja w architekturze <a href="/en-US/docs/Glossary/MVC">MVC</a>)</p>

<p>W dalszych rozdziałach będziemy korzystać <em>Express Application Generator</em>, który tworzy modularny szkielet aplikacji, którą możemy łatwo rozbudowywać.</p>

<ul>
</ul>

<h2 id="Podsumowanie">Podsumowanie</h2>

<p>Gratulacje, zrobiłeś pierwszy krok w swojej podróży z Express/Node! Mam nadzieję, że dobrze poznałeś najważniejsze zalety środowiska Express/Node i zrozumiałeś ogólne działanie najważniejszych elementów aplikacji (funkcje obsługi żądań, warstwa pośrednia, obsługa błędów, szablony widoków. Powinieneś też rozumieć, że Express jako elastyczny framework, nie narzuca Ci sposobu łączenia elementy aplikacji, ale Tobie pozostawia w tej kwestii wybór.</p>

<p>W założeniu twórców Express jest lekkim frameworkiem. dlatego wiele jego zalet i możliwości pochodzi z bibliotek  i funkcji firm trzecich. Będziemy im się przyglądać bardzie szczegółowo w dalszych częściach cyklu. W następnym artykule będziemy poznawać konfigurację środowiska uruchomieniowego Node.</p>

<h2 id="Zobacz_także">Zobacz także</h2>

<ul>
 <li><a href="https://medium.com/@ramsunvtech/manage-multiple-node-versions-e3245d5ede44">Venkat.R - Manage Multiple Node versions</a></li>
 <li><a href="https://nodejs.org/api/modules.html#modules_modules">Modules</a> (Node API docs)</li>
 <li><a href="https://expressjs.com/">Express</a> (home page)</li>
 <li><a href="http://expressjs.com/en/starter/basic-routing.html">Basic routing</a> (Express docs)</li>
 <li><a href="http://expressjs.com/en/guide/routing.html">Routing guide</a> (Express docs)</li>
 <li><a href="http://expressjs.com/en/guide/using-template-engines.html">Using template engines with Express</a> (Express docs)</li>
 <li><a href="https://expressjs.com/en/guide/using-middleware.html">Using middleware</a> (Express docs)</li>
 <li><a href="http://expressjs.com/en/guide/writing-middleware.html">Writing middleware for use in Express apps</a> (Express docs)</li>
 <li><a href="https://expressjs.com/en/guide/database-integration.html">Database integration</a> (Express docs)</li>
 <li><a href="http://expressjs.com/en/starter/static-files.html">Serving static files in Express</a> (Express docs)</li>
 <li><a href="http://expressjs.com/en/guide/error-handling.html">Error handling</a> (Express docs)</li>
</ul>

<div>{{NextMenu("Learn/Server-side/Express_Nodejs/development_environment", "Learn/Server-side/Express_Nodejs")}}</div>

<h2 id="W_tym_module">W tym module</h2>

<ul>
 <li><a href="/pl/docs/Learn/Server-side/Express_Nodejs/Introduction">Wprowadzenie do Express/Node</a></li>
 <li><a href="/pl/docs/Learn/Server-side/Express_Nodejs/development_environment">Setting up a Node (Express) development environment</a></li>
 <li><a href="/pl/docs/Learn/Server-side/Express_Nodejs/Tutorial_local_library_website">Express Tutorial: The Local Library website</a></li>
 <li><a href="/en-US/docs/Learn/Server-side/Express_Nodejs/skeleton_website">Express Tutorial Part 2: Creating a skeleton website</a></li>
 <li><a href="/en-US/docs/Learn/Server-side/Express_Nodejs/mongoose">Express Tutorial Part 3: Using a Database (with Mongoose)</a></li>
 <li><a href="/en-US/docs/Learn/Server-side/Express_Nodejs/routes">Express Tutorial Part 4: Routes and controllers</a></li>
 <li><a href="/en-US/docs/Learn/Server-side/Express_Nodejs/Displaying_data">Express Tutorial Part 5: Displaying library data</a></li>
 <li><a href="/en-US/docs/Learn/Server-side/Express_Nodejs/forms">Express Tutorial Part 6: Working with forms</a></li>
 <li><a href="/en-US/docs/Learn/Server-side/Express_Nodejs/deployment">Express Tutorial Part 7: Deploying to production</a></li>
</ul>
