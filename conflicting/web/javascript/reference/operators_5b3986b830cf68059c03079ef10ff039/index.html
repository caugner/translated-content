---
title: Vergleichsoperatoren
slug: >-
  conflicting/Web/JavaScript/Reference/Operators_5b3986b830cf68059c03079ef10ff039
tags:
  - JavaScript
  - Operator
  - Reference
translation_of: Web/JavaScript/Reference/Operators
translation_of_original: Web/JavaScript/Reference/Operators/Comparison_Operators
original_slug: Web/JavaScript/Reference/Operators/Vergleichsoperatoren
---
<div>{{jsSidebar("Operators")}}</div>

<p>JavaScript kennt sowohl den strikten als auch den Typ konvertierenden Vergleich. Ein strikter Vergleich (z. B. <code>===</code>) gibt nur true zurück, wenn der gleiche Typ und der gleiche Wert vorhanden sind. Der häufiger verwendete abstrakte Vergleich (z. B. <code>==</code>) wandelt die Operanden in den gleichen Typen um, bevor sie verglichen werden. Bei relationalen Vergleichsoperatoren (z. B. <code>&lt;=</code>) werden die Operanden vor dem Vergleich zuerst in elementare Datentypen konvertiert und dann in gleiche Typen umgewandelt.</p>

<p>Strings werden entsprechend der lexikographischen Ordnung, basierend auf den Unicode, verglichen.</p>

<div>{{EmbedInteractiveExample("pages/js/expressions-comparisonoperators.html")}}</div>



<p>Merkmale von Vergleichen:</p>

<ul>
 <li>Zwei Strings sind strikt gleich, wenn sie die gleiche Abfolge von Zeichen, die gleiche Länge und die gleichen Zeichen in übereinstimmenden Positionen haben.</li>
 <li>Zwei Zahlen sind strikt gleich, wenn sie numerisch gleich sind (den gleichen Zahlwert haben). <a href="/de/docs/Web/JavaScript/Reference/Global_Objects/NaN" title="NaN">NaN</a> ist mit nichts gleich, auch nicht mit sich selbst. +0 und -0 sind strikt gleich zueinander.</li>
 <li>Zwei Boolesche Operanden sind exakt gleich wenn beide <code>true</code> oder beide <code>false</code> sind.</li>
 <li>Zwei unterschiedliche Objekte sind niemals gleich, weder in strikten noch nicht-strikten Vergleichen.</li>
 <li>Ein Ausdruck, der Objekte vergleicht, gilt nur als <code>true</code>, wenn die Operanden auf das gleiche Objekt zeigen.</li>
 <li>Die Typen <code>Null</code> und <code>undefined</code> sind immer strikt gleich zu sich selbst und abstrakt gleich zueinander.</li>
</ul>

<h2 id="Gleichheitsoperatoren">Gleichheitsoperatoren</h2>

<h3 id="Gleichheit_()">Gleichheit (==)</h3>

<p>Der Gleichheitsoperator konvertiert die Operanden, wenn sie <strong>nicht vom gleichen Typs</strong> sind und prüft dann auf strikte Gleichheit. Sind <strong>beide Operanden Objekte</strong>, vergleicht JavaScript die Referenzen; Referenzen gelten als gleich, wenn sie auf das gleiche Objekt im Speicher zeigen.</p>

<h4 id="Syntax">Syntax</h4>

<pre class="syntaxbox">x == y
</pre>

<h4 id="Beispiele">Beispiele</h4>

<pre class="brush: js">1    ==  1     // true
'1'  ==  1     // true
1    == '1'    // true
0    == false  // true
0    == null   // false
var object1 = {'key': 'value'}, object2 = {'key': 'value'}
object1 == object2 // false
0    == undefined  // false
null == undefined  // true
</pre>

<h3 id="Ungleichheit_(!)">Ungleichheit (!=)</h3>

<p>Der Ungleichheitsoperator gibt true zurück, wenn die Operanden nicht gleich sind. Wenn die beiden Operanden <strong>nicht vom gleichen Typ </strong>sind, versucht JavaScript die Operanden in einen, für den Vergleich passenden Typ, umzuwandeln. Wenn <strong>beide Operanden Objekte sind</strong>, vergleicht JavaScript die Referenzen; Referenzen sind ungleich, wenn sie auf verschiedene Objekte im Speicher verweisen.</p>

<p>Syntax</p>

<pre class="syntaxbox">x != y</pre>

<h4 id="Beispiele_2">Beispiele</h4>

<pre class="brush: js">1 !=   2     // true
1 !=  "1"    // false
1 !=  '1'    // false
1 !=  true   // false
0 !=  false  // false
</pre>

<h3 id="Identität_strikte_Gleichheit_()">Identität / strikte Gleichheit (===)</h3>

<p>Der Identitätsoperator gibt true zurück, wenn die Operanden strikt gleich sind (siehe oben) <strong>ohne eine Typkonvertierung</strong></p>

<h4 id="Syntax_2">Syntax</h4>

<pre class="syntaxbox">x === y</pre>

<h4 id="Beispiele_3">Beispiele</h4>

<pre class="brush: js ">3 === 3   // true
3 === '3' // false
var object1 = {'key': 'value'}, object2 = {'key': 'value'}
object1 === object2 // false
</pre>

<h3 id="Nicht_identisch_Strikte_Ungleichheit_(!)">Nicht identisch / Strikte Ungleichheit (!==)</h3>

<p>Der strikte Ungleichheitsoperator gibt true zurück, wenn die Operanden<strong> nicht vom gleichen Typ sind bzw. ungleich sind</strong>.</p>

<h4 id="Syntax_3">Syntax</h4>

<pre class="syntaxbox">x !== y</pre>

<h4 id="Beispiele_4">Beispiele</h4>

<pre class="brush: js">3 !== '3' // true
4 !== 3   // true
</pre>

<h2 id="Relationale_Operatoren">Relationale Operatoren</h2>

<p>Jeder dieser Operatoren wird die <code>valueOf()</code> Funktion aufrufen, bevor ein Vergleich durchgeführt wird.</p>

<h3 id="Größer-als-Operator_(>)">Größer-als-Operator (&gt;)</h3>

<p>Der Größer-als-Operator gibt true zurück, wenn der linke Operand größer als der rechte Operand ist.</p>

<h4 id="Syntax_4">Syntax</h4>

<pre class="syntaxbox">x &gt; y</pre>

<h4 id="Beispiele_5">Beispiele</h4>

<pre class="brush: js">4 &gt; 3 // true
</pre>

<h3 id="Größer-oder-gleich-Operator_(>)">Größer-oder-gleich-Operator (&gt;=)</h3>

<p>Der Größer-oder-gleich-Operator gibt true zurück, wenn der linke Operand größer als oder gleich dem rechten Operanden ist.</p>

<h4 id="Syntax_5">Syntax</h4>

<pre class="syntaxbox"> x &gt;= y</pre>

<h4 id="Beispiele_6">Beispiele</h4>

<pre class="brush: js">4 &gt;= 3 // true
3 &gt;= 3 // true
</pre>

<h3 id="Kleiner-als-Operator_(&lt;)">Kleiner-als-Operator (&lt;)</h3>

<p>Der Kleiner-als-Operator gibt true zurück, wenn der linke Operand kleiner als der rechte Operand ist.</p>

<h4 id="Syntax_6">Syntax</h4>

<pre class="syntaxbox"> x &lt; y</pre>

<h4 id="Beispiele_7">Beispiele</h4>

<pre class="brush: js">3 &lt; 4 // true
</pre>

<h3 id="Kleiner-oder-gleich-Operator_(&lt;)">Kleiner-oder-gleich-Operator (&lt;=)</h3>

<p>Der Kleiner-oder-gleich-Operator gibt true zurück, wenn der linke Operand kleiner oder gleich dem rechten Operanden ist.</p>

<h4 id="Syntax_7">Syntax</h4>

<pre class="syntaxbox"> x &lt;= y</pre>

<h4 id="Beispiele_8">Beispiele</h4>

<pre class="brush: js">3 &lt;= 4 // true
</pre>

<h2 id="Die_Gleichheitsoperatoren_anwenden">Die Gleichheitsoperatoren anwenden</h2>

<p>Die Standard-Gleichheitsoperatoren (<code>==</code> und <code>!=</code>) benutzen den <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3">Abstract Equality Comparison Algorithmus</a>, um zwei Operanden zu vergleichen. Sind die Operanden unterschiedlichen Typs, wird vor dem Vergleich zuerst versucht sie in gleiche Typen umzuwandeln; z.B. wird beim Ausdruck <code>5 == '5'</code>  das Zeichen auf der rechten Seite in eine Zahl konvertiert.</p>

<p>Die strikten Gleichheitsoperatoren (<code>===</code> und <code>!==</code>) benutzen den <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.6">Strict Equality Comparison Algorithmus</a> und sind dafür gedacht, Operanden des gleichen Typs zu vergleichen. Wenn die Operanden von unterschiedlichen Typen sind, ist das Ergebnis immer <code>false</code>, wie <code>5 !== '5'</code>.</p>

<p>Strikte Gleichheitsoperatoren sollten verwendet werden, wenn die Operanden sowohl einen bestimmten Typen als auch Wert haben sollen. Ansonsten benutzt man die abstrakten Gleichheitsoperatoren, die es einem erlauben Operanden unterschiedlicher Typen zu vergleichen.</p>

<p>Wenn beim Vergleich eine Typkonvertierung vorgenommen wird (z.B. beim nicht-strikten Vergleich), konvertiert JavaScript in die Typen {{jsxref("String")}}, {{jsxref("Number")}}, {{jsxref("Boolean")}} und {{jsxref("Object")}} und führt den Vergleich dann aus:</p>

<ul>
 <li>Wenn eine Zahl und eine Zeichenkette verglichen werden, wird die Zeichenkette zu einem Zahlenwert umgewandelt. JavaScript versucht das numerische Zeichenliteral in einen Wert des Typs <code>Number</code> zu wandeln. Zuerst wird der mathematische Wert des numerischen Zeichenliterals ermittelt. Danach wird der Wert auf den nächsten Wert des Typs <code>Number</code> gerundet.</li>
 <li>Wenn einer der Operanden ein Boolescher Typ ist, wird der Operand zur 1 konveriert wenn er <code>true</code> ist und zur +0 wenn <code>false</code>.</li>
 <li>Wenn ein Objekt mit einer Zahl oder einer Zeichenkette verglichen wird,  versucht JavaScript den Defaultwert für das Objekt zurückzugeben. Operatoren versuchen das Objekt in einen elementaren Wert (<code>String</code> oder <code>Number)</code> umzuwandeln, indem sie die <code>valueOf</code> und <code>toString</code> Methoden der Objekte benutzen. Kann ein Objekt nicht umgewandelt werden, wird ein Laufzeitfehler erzeugt.</li>
 <li>Ein Objekt wird nur dann in einen elementaren Datentypen umgewandelt, wenn sein Vergleichsoperand ein elementarer Datentyp ist. Sind beide Operanden Objekte, werden sie als Objekte verglichen und der Gleichheitstest liefert nur dann true, wenn beide auf das gleiche Objekt zeigen.</li>
</ul>

<div class="note"><strong>Hinweis:</strong> String Objekte sind vom Typ Objekte, nicht String! String Objekte werden selten eingesetzt, so dass das folgende Ergebnis überraschend sein kann:</div>

<pre class="brush:js">// true, da beide Operanden vom Typ String sind (string primitives)
'foo' === 'foo'

var a = new String('foo');
var b = new String('foo');

// false, da a und b auf verschiedene Objekte zeigen
a == b

// false, da a und b auf verschiedene Objekte zeigen
a === b

// true, da a und 'foo' verschiedene Typen sind und das Objekt (a)
// vor dem Vergleich zum String 'foo' umgewandelt wird
a == 'foo' </pre>

<h2 id="Spezifikationen">Spezifikationen</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Spezifikation</th>
   <th scope="col">Status</th>
   <th scope="col">Kommentar</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Initial Definition. Implementiert in JavaScript 1.0</td>
  </tr>
  <tr>
   <td>{{SpecName('ES3')}}</td>
   <td>{{Spec2('ES3')}}</td>
   <td>Fügt <code>===</code> und <code>!==</code> Operatoren hinzu. Implementiert in JavaScript 1.3</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-11.8')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td>In verschiedenen Kapiteln der Spezifikation definiert: <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.8">Relational Operators</a>, <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9">Equality Operators</a></td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-relational-operators')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td>In verschiedenen Kapiteln der Spezifikation definiert: <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-relational-operators">Relational Operators</a>, <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-equality-operators">Equality Operators</a></td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-relational-operators')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td>In verschiedenen Kapiteln der Spezifikation definiert: <a href="http://tc39.github.io/ecma262/#sec-relational-operators">Relational Operators</a>, <a href="http://tc39.github.io/ecma262/#sec-equality-operators">Equality Operators</a></td>
  </tr>
 </tbody>
</table>

<h2 id="Browserkompatibilität">Browserkompatibilität</h2>



<p>{{Compat("javascript.operators.comparison")}}</p>

<h2 id="Siehe_auch">Siehe auch</h2>

<ul>
 <li>{{jsxref("Object.is()")}}</li>
 <li>{{jsxref("Math.sign()")}}</li>
 <li><a href="/de/docs/Web/JavaScript/Equality_comparisons_and_sameness">Equality comparisons and sameness</a></li>
</ul>
