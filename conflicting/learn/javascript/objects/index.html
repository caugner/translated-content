---
title: Einführung in objektorientiertes JavaScript
slug: conflicting/Learn/JavaScript/Objects
tags:
  - Constructor
  - Encapsulation
  - Inheritance
  - Intermediate
  - JavaScript
  - Members
  - Namespace
  - OOP
  - Object
  - Object-Oriented
translation_of: Learn/JavaScript/Objects
translation_of_original: Web/JavaScript/Introduction_to_Object-Oriented_JavaScript
original_slug: Web/JavaScript/Introduction_to_Object-Oriented_JavaScript
---
<div>{{jsSidebar("Introductory")}}</div>

<p>Im Kern ist JavaScript eine objektorientierte Programmiersprache mit mächtigen und flexiblen Fähigkeiten der {{Glossary("OOP")}}. Dieser Artikel beginnt mit einer Einführung in die objektorientierte Programmierung. Im zweiten Teil wird das Objektmodel von JavaScript erläutert. Danach folgt eine praktische Vorstellung der objektorientierten Programmierung in JavaScript. Dieser Artikel beschreibt nicht die neuere Syntax für {{jsxref("Classes", "objektorientierte Programmierung in ECMAScript 6", "", 1)}}.</p>

<h2 id="JavaScript_Review" name="JavaScript_Review">JavaScript Review</h2>

<p>Wenn Sie nicht mit den Konzepten in JavaScript, wie zum Beispiel Variablen, Typen, Funktionen und Geltungsbereich, vertraut sind, lesen Sie bitte zuerst den Artikel <a href="/de/docs/Web/JavaScript/Eine_Wiedereinfuehrung_in_JavaScript">Eine Wiedereinführung in JavaScript</a>. Sie können ebenfalls auf den <a href="/de/docs/Web/JavaScript/Guide">JavaScript Guide</a> zurückgreifen.</p>

<h2 id="Object-oriented_programming" name="Object-oriented_programming">Objektorientierte Programmierung</h2>

<p>Die objektorientierte Programmierung ist ein Paradigma, in dem über Abstraktion Modelle basierend auf der realen Welt erstellt werden. Es verwendet Techniken, die von zuvor etablierten Paradigmen eingeführt wurden. Darunter befinden sich Modularität, Polymorphismus und Datenkapselung. Heutzutage unterstützen viele populäre Programmiersprachen (z.B.: Java, JavaScript, C#, C++, Python, PHP, Ruby und Objective-C) die objektorientierte Programmierung (OOP).</p>

<p>Objektorientierte Programmierung kann als das Design einer Software unter der Verwendung von kooperierenden Objekten angesehen werden. Die traditionelle Ansicht dagegen sieht ein Programm als eine Menge von Funktionen oder noch einfacher als eine Abfolge von Instruktionen an den Computer. In der OOP kann jedes Objekt Nachrichten empfangen, Daten verarbeiten und Nachrichten an andere Objekte senden. Jedes Objekt kann als eine unabhängige kleine Maschine mit einer bestimmten Rolle oder Verantwortlichkeit angesehen werden.</p>

<p>Die Objektorientierte Programmierung versucht höhere Flexibilität und Wartbarkeit in Programmen zu ermöglichen und wird deshalb oft beim Software Engineering von hochskalierenden Programmen eingesetzt. Durch die starke Konzentration auf Modularität hat objektorientierter Code den Vorteil, dass er einfacher zu entwickeln und zu verstehen ist. Sie konzentriert sich direkter auf die Analyse, die Codierung und das Verstehen von komplexen Situationen und Prozeduren als weniger modulare Programmiermethoden.<a href="#cite-1"><sup>1</sup></a></p>

<h2 id="Terminology" name="Terminology">Begriffsdefinitionen</h2>

<dl>
 <dt>{{Glossary("Namespace")}}</dt>
 <dd>Ein Container, der Entwicklern die Bündelung von Funktionalität unter einem eindeutigen, applikationsspezifischen Namen ermöglicht.</dd>
 <dt>{{Glossary("Klasse")}}</dt>
 <dd>Definiert die Eigenschaften eines Objekts. Sie ist die Definition einer Vorlage von Variablen und Methoden eines Objekts.</dd>
 <dt>{{Glossary("Objekt")}}</dt>
 <dd>Eine Instanz einer Klasse.</dd>
 <dt>{{Glossary("Eigenschaft")}}</dt>
 <dd>Eine Eigenschaft eines Objekts, wie zum Beispiel eine Farbe.</dd>
 <dt>{{Glossary("Methode")}}</dt>
 <dd>Eine Fähigkeit eines Objekts, wie zum Beispiel laufen. Sie ist eine Unterroutine oder Funktion, die mit der Klasse assoziiert ist.</dd>
 <dt>{{Glossary("Konstruktor")}}</dt>
 <dd>Eine spezielle Methode, die zur Instanziierung eines Objekts aufgerufen wird. Sie hat gewöhnlicherweise denselben Namen wie die Klasse, zu der sie gehört.</dd>
 <dt>{{Glossary("Vererbung")}}</dt>
 <dd>Eine Klasse kann die Eigenschaften und Fähigkeiten von anderen Klassen erben und somit für sich verwenden.</dd>
 <dt>{{Glossary("Datenkapselung")}}</dt>
 <dd>Die Datenkapselung ist eine Technik, um die Daten und die Methoden, die diese Daten verwenden, miteinander zu bündeln.</dd>
 <dt>{{Glossary("Abstraktion")}}</dt>
 <dd>Die Verknüpfung von komplexer Vererbung, Methoden und Eigenschaften eines Objekts müssen ein Modell der Realität simulieren können.</dd>
 <dt>{{Glossary("Polymorphismus")}}</dt>
 <dd>Poly bedeute "<em>viele</em>"  und Morphismus bedeutet "<em>Formen</em>". Verschiedene Klassen können dieselbe Methode oder dieselbe Eigenschaft definieren.</dd>
</dl>

<p>Lesen Sie bitte den Artikel {{interwiki("wikipedia", "Objektorientierte Programmierung")}} auf Wikipedia für eine umfassendere Beschreibung der objektorientierten Programmierung.</p>

<h2 id="Prototypenbasierte_Programmierung">Prototypenbasierte Programmierung</h2>

<p>Prototypenbasierte Programmierung ist eine Art der objektorientierten Programmierung bei der keine Klassen gegenwärtig sind. Die Wiederverwendung von Verhalten (bekannt als Vererbung in klassenbasierten Programmiersprachen) wird über das Dekorieren von existierenden Objekten erreicht, die als Prototyp dienen. Dieses Modell wird als klassenlose, prototyporientierte oder instanzorientierte Programmierung bezeichnet.</p>

<p>Das ursprüngliche (und am meisten kanonische) Beispiel einer prototypenbasierten Programmiersprache ist {{interwiki("wikipedia", "Self (Programmiersprache)")}}, welche von David Ungar and Randall Smith entwickelt wurde. Seitdem wurde die klassenlose Programmierung immer mehr populär und wurde für andere Programmiersprachen wie JavaScript, Cecil, NewtonScript, Io, MOO, REBOL, Kevo, Squeak (wenn das Viewer Framework zur Manipulation von Morphic Komponenten verwendet wird) und einige andere adoptiert.<a href="#cite-2"><sup>2</sup></a></p>

<h2 id="JavaScript_Object_Oriented_Programming" name="JavaScript_Object_Oriented_Programming">Objektorientierte Programmierung mit JavaScript</h2>

<h3 id="Namespace">Namespace</h3>

<p>Ein Namespace ist ein Container in dem Entwickler Funktionalitäten unter einem eindeutigen, applikationsspezifischen Namen zusammenfassen können. <strong>In JavaScript ist ein Namespace ein gewöhnliches Objekt, welches Methoden, Eigenschaften und Objekte enthält.</strong></p>

<div class="note">
<p>Im Gegensatz zu manchen anderen objektorientierten Programmiersprachen gibt es in der Sprachebene von JavaScript keinen Unterschied zwischen einem regulären Objekt und einem Namespace.</p>
</div>

<p>Die Idee hinter der Erstellung eines Namespaces in JavaScript ist simpel: es wird ein globales Objekt erstellt, welches alle Variablen, Methoden und Funktionen als Eigenschaften besitzt. Zusätzlich kann die Verwendung von Namespaces Namenskonflikten in der Applikation vorbeugen.</p>

<p>Es wird ein globales Objekt names MYAPP erstellt:</p>

<pre class="brush: js">// global namespace
var MYAPP = MYAPP || {};</pre>

<p>Im obigen Code wird zuerst geprüft, ob MYAPP bereits definiert wurde (entweder in derselben oder einer anderen Datei). Wenn MYAPP bereits definiert wurde, wird das globale Objekt MYAPP verwendet. Anderenfalls wird ein leeres Objekt names MYAPP erstellt, welches später Methoden, Funktionen, Variablen und andere Objekte kapseln kann.</p>

<p>Innerhalb eines Namespaces können weitere Namespaces erstellt werden:</p>

<pre class="brush: js">// sub namespace
MYAPP.event = {};</pre>

<p>Der folgende Code erstellt einen Namespace und fügt diesem Variablen, Funktionen und Methoden hinzu:</p>

<pre class="brush: js">// Create container called MYAPP.commonMethod for common method and properties
MYAPP.commonMethod = {
  regExForName: "", // define regex for name validation
  regExForPhone: "", // define regex for phone no validation
  validateName: function(name){
    // Do something with name, you can access regExForName variable
    // using "this.regExForName"
  },

  validatePhoneNo: function(phoneNo){
    // do something with phone number
  }
}

// Object together with the method declarations
MYAPP.event = {
    addListener: function(el, type, fn) {
    //  code stuff
    },
   removeListener: function(el, type, fn) {
    // code stuff
   },
   getEvent: function(e) {
   // code stuff
   }

   // Can add another method and properties
}

//Syntax for Using addListner method:
MYAPP.event.addListener("yourel", "type", callback);</pre>

<h3 id="Core_Objects" name="Core_Objects">Standardmäßig eingebaute Objekte</h3>

<p>JavaScript besitzt verschiedene Objekte im Kern. Darunter befinden sich zum Beispiel die Objekte Math, Object, Array, und String. Das folgende Beispiel zeigt, wie das Math Objekt mit der <code>random()</code> Methode eine Zufallszahl generiert.</p>

<pre class="brush: js">console.log(Math.random());
</pre>

<div class="note"><strong>Hinweis:</strong> Dieses und folgende Beispiele setzen voraus, dass {{domxref("console.log()")}} global definiert wurde. Die <code>console.log</code> Funktion ist kein eigentlicher Sprachteil von JavaScript, jedoch implementieren viele Browser diese zum Debuggen.</div>

<p>Siehe <a href="/de/docs/Web/JavaScript/Reference/Global_Objects" title="en-US/docs/Web/JavaScript/Reference/Global_Objects">JavaScript Reference: Standard built-in objects</a> für eine List aller Objekte im Kern von JavaScript.</p>

<p>Jedes Objekt in JavaScript ist eine Instanz des Objekts <a href="/de/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a> und erbt somit alle Eigenschaften und Methoden von diesem.</p>

<h3 id="Custom_Objects" name="Custom_Objects">Eigene Objekte</h3>

<h4 id="The_Class" name="The_Class">Die Klasse</h4>

<p>JavaScript ist eine prototypenbasierte Programmiersprache, welche im Gegensatz zu C++ oder Java keine class Anweisung enthält. Dies kann für Programmierer manchmal verwirrend sein, wenn sie normalerweise Programmiersprachen mit einer class Anweisung verwenden. JavaScript verwendet stattdessen Funktionen als Klassen. Die Definition einer Klasse erfolgt analog zu der einer Funktion. Im folgenden Beispiel wird eine neue Klasse namens Person definiert.</p>

<pre class="brush: js">var Person = function(){ }
</pre>

<h4 id="The_Object_.28Class_Instance.29" name="The_Object_.28Class_Instance.29">Das Objekt (Instanz einer Klasse)</h4>

<p>Um eine neue Instanz eines Objekts <em><code>obj</code></em> zu erstellen, wird die Anweisung <code>new <em>obj</em></code> ausgeführt. Das Ergebnis der Anweisung (welches den Typ <em><code>obj</code></em> hat) wird für eine spätere Verwendung einer Variablen zugewiesen.</p>

<p>Im folgenden Beispiel wird eine Klasse mit dem Namen <code>Person</code> definiert und zwei Objekte (<code>person1</code> and <code>person2</code>) instanziiert.</p>

<pre class="brush: js">var person1 = new Person();
var person2 = new Person();
</pre>

<div class="note">Lesen Sie bitte {{jsxref("Object.create()")}} für eine neue, alternative Methode zur Objektinstanziierung.</div>

<h4 id="The_Constructor" name="The_Constructor">Der Konstruktor</h4>

<p>Der Konstruktor wird zum Zeitpunkt der Instanziierung (wenn eine Objektinstanz erstellt wird) aufgerufen. Er ist als eine Methode der Klasse definiert. In JavaScript agiert die Funktion als Konstruktor für das Objekt. Somit muss keine Methode explizit für den Konstruktor definiert werden. Jede deklarierte Anweisung in der Klasse wird zum Zeitpunkt der Instanziierung ausgeführt.</p>

<p>Der Konstruktor wird zur Initialisierung der Eigenschaften oder vorbereitende Methodenaufrufe zur Verwendung des Objekts verwendet. Das Hinzufügen von Klassenmethoden und deren Definitionen verwendet eine andere Syntax, welche später im Artikel erläutert wird.</p>

<p>Im folgenden Beispiel loggt der Konstruktor der Klasse <code>Person</code> eine Nachricht, wenn ein <code>Person</code> Objekt instanziiert wird.</p>

<pre class="brush: js">function Person() {
  console.log('Instanz erstellt');
}

var person1 = new Person();
var person2 = new Person();
</pre>

<h4 id="The_Property_.28object_attribute.29" name="The_Property_.28object_attribute.29">Die Eigenschaft (Objektattribut)</h4>

<p>Eigenschaften sind Variablen innerhalb einer Klasse. Jede Instanz des Objekts besitzt diese Eigenschaften. Eigenschaften sollten im Prototyp der Eigenschaft in der Klasse (Funktion) gesetzt werden, damit die Vererbung korrekt funktioniert.</p>

<p>Eigenschaften können innerhalb eines Objekts mit dem Schlüsselwort <code>this</code>, welches das aktuelle Objekt referenziert, verwendet werden. Der Zugriff (lesen oder schreiben) auf eine Eigenschaft von außerhalb der Klasse wird durch die Syntax <code>InstanceName.Property</code> ermöglicht. Diese Syntax ist analog zu C++, Java und zahlreichen anderen Programmiersprachen. Innerhalb der Klasse wird die Syntax <code>this.Property</code> zum Lesen oder Schreiben des Werts verwendet.</p>

<p>Im folgenden Beispiel wird die Eigenschaft <code>firstName</code> für die <code>Person</code> Klasse definiert. Bei der Instanziierung wird ihr ein Wert zugewiesen.</p>

<pre class="brush: js">function Person(firstName) {
  this.firstName = firstName;
  console.log('Person instantiated');
}

var person1 = new Person('Alice');
var person2 = new Person('Bob');

// Zeigt die Eigenschaft firstName des Objektes
console.log('person1 is ' + person1.firstName); // logs "person1 is Alice"
console.log('person2 is ' + person2.firstName); // logs "person2 is Bob"
</pre>

<h4 id="The_methods" name="The_methods">Die Methoden</h4>

<p>Methoden befolgen beinahe dieselbe Logik wie Eigenschaften mit dem Unterschied, dass sie Funktionen sind und deshalb als Funktionen definiert werden. Der Aufruf einer Funktion erfolgt analog zu Eigenschaften gefolgt von <code>()</code> am Ende des Methodennames. Innerhalb der Klammern können der Methode Argumente übergeben werden. Um eine Methode zu definieren, muss eine Funktion einer benannten Eigenschaft der <code>prototype</code> Eigenschaft der Klasse zugewiesen werden. Der Name der benannten Eigenschaft dient nun als Methodenname über den die Methode auf dem Objekt aufgerufen werden kann.</p>

<p>Im folgenden Beispiel wird die Methode <code>sayHello()</code> für die <code>Person</code> Klasse definiert.</p>

<pre class="brush: js">function Person(firstName) {
  this.firstName = firstName;
}

Person.prototype.sayHello = function() {
  console.log("Hello, I'm " + this.firstName);
};

var person1 = new Person("Alice");
var person2 = new Person("Bob");

// Aufrufen der Methode sayHello der Person.
person1.sayHello(); // logs "Hello, I'm Alice"
person2.sayHello(); // logs "Hello, I'm Bob"
</pre>

<p>Methoden in JavaScript sind gewöhnliche Funktionsobjekte, die als eine Eigenschaft an ein Objekt gebunden werden. Dadurch können Methoden auch "außerhalb des Kontexts" aufgerufen werden. Das folgende Beispiel veranschaulicht dies:</p>

<pre class="brush: js">function Person(firstName) {
  this.firstName = firstName;
}

Person.prototype.sayHello = function() {
  console.log("Hello, I'm " + this.firstName);
};

var person1 = new Person("Alice");
var person2 = new Person("Bob");
var helloFunction = person1.sayHello;

// logs "Hello, I'm Alice"
person1.sayHello();

// logs "Hello, I'm Bob"
person2.sayHello();

// logs "Hello, I'm undefined" (oder schlägt
// mit einem TypeError im strict mode fehl)
helloFunction();

// logs true
console.log(helloFunction === person1.sayHello);

// logs true
console.log(helloFunction === Person.prototype.sayHello);

// logs "Hello, I'm Alice"
helloFunction.call(person1);</pre>

<p>Das Beispiel zeigt, dass alle Referenzen zur <code>sayHello</code> Funktion — die auf <code>person1</code>, auf <code>Person.prototype</code>, in der <code>helloFunction</code> Variable, etc. — <em>dieselbe Funktion</em> referenzieren. Der Wert von <code>this</code> während eines Funktionsaufrufs hängt von der Art ab, wie die Funktion aufgerufen wird. In allgemeinen Fällen, wenn die Funktion in einem Ausdruck  über die Eigenschaft aufgerufen wird — <code>person1.sayHello()</code> — referenziert <code>this</code> das Objekt, auf der die Funktion aufgerufen wird (<code>person1</code>). Deshalb verwendet <code>person1.sayHello()</code> den Namen "Alice" und <code>person2.sayHello()</code> den Namen "Bob". Wenn die Funktion über andere Arten aufgerufen wird, ist <code>this</code> unterschiedlich definiert: Der Aufruf von der Variablen aus — <code>helloFunction()</code> — setzt <code>this</code> auf das globale Objekt (<code>window</code>, in Webbbrowsern). Da dieses Objekt (wahrscheinlich) keine <code>firstName</code> Eigenschaft besitzt, gitb die Funktion "Hello, I'm undefined" aus. (Dieses Ergebnis wird im Loose Mode produziert. Im <a href="/en-US/docs/Web/JavaScript/Reference/Strict_mode" title="/en/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode">Strict Mode</a> verhält sich die Funktion anders und es könnte ein Fehler ausgelöst werden. Um Verwirrungen zu vermeiden wird dies nicht weiter im Detail besprochen) <code>this</code> kann auch explizit über <code>Function#call</code> (oder <code>Function#apply</code>) definiert werden. Die geschieht in der letzten Zeile des obigen Beispiels.</p>

<div class="note"><strong>Hinweis:</strong> Mehr über <code>this</code> können Sie unter <a href="/de/docs/Web/JavaScript/Reference/Global_Objects/Function/call" title="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call">Function#call</a> und <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" title="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply">Function#apply</a> finden.</div>

<h4 id="Inheritance" name="Inheritance">Vererbung</h4>

<p>Vererbung ist eine Methode, um eine Klasse zu erstellen, die eine spezialisierte Version von einer (Einfachvererbung) oder mehrerer (Mehrfachvererbung) Klassen ist (<em>JavaScript unterstützt nur Einfachvererbung</em>). Die spezialisierte Klasse wird normalerweise als <em>child</em> bezeichnet. Die Klasse, von der geerbt wird, wird als <em>parent</em> bezeichnet. Vererbung in JavaScript funktioniert indem eine Instanz der <em>parent</em> Klasse der <em>child</em> Klasse zugewiesen und dann spezialisiert wird. In modernen Webbrowsern kann die Vererbung auch mittels der Verwendung von <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Classical_inheritance_with_Object.create" title="/en-US/docs/JavaScript/Reference/Global_Objects/Object/create#Classical_inheritance_with_Object.create">Object.create</a> implementiert werden.</p>

<div class="note"><strong>Hinweis:</strong> JavaScript erkennt den Konstruktor <code>prototype.constructor</code> (siehe <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype">Object.prototype</a>) der child Klasse nicht. Er muss manuell angegeben werden. Sehe dazu zusätzlich den Beitrag "<a href="https://stackoverflow.com/questions/8453887/why-is-it-necessary-to-set-the-prototype-constructor">Why is it necessary to set the prototype constructor?</a>" (englisch) auf Stackoverflow an.</div>

<p>Im folgenden Beispiel wird die Klasse <code>Student</code> als <em>child</em> Klasse von <code>Person</code> definiert. Dann wird die Methode <code>sayHello()</code> neu definiert und die Methode <code>sayGoodBye()</code> zur Klasse <code>Person</code> hinzugefügt.</p>

<pre class="brush: js">// Definiert den Person Konstruktor
function Person(firstName) {
  this.firstName = firstName;
}

// Fügt Methoden zum Person.prototype hinzu
Person.prototype.walk = function(){
  console.log("I am walking!");
};
Person.prototype.sayHello = function(){
  console.log("Hello, I'm " + this.firstName);
};

// Definiert den Student Konstruktor
function Student(firstName, subject) {
  // Call the parent constructor, making sure (using Function#call)
  // that "this" is set correctly during the call
  Person.call(this, firstName);

  // Initialize our Student-specific properties
  this.subject = subject;
};

// Erstellt ein Student.prototype Objekt das von Person.prototype erbt.
// Hinweis: Ein häufiger Fehler ist der Einsatz von "new Person()" beim erstellen vomeines
// Student.prototype. Das ist falsch aus einigen Gründen, nicht nur
// das wir keinen Parameter der Person für "firstName" mitgeben können.
// Der korrekte Ort für den Aufruf von Person ist oben, wo wir es
// von Student aufrufen.
Student.prototype = Object.create(Person.prototype); // See note below

// Setzt die "constructor" Eigenschaft um auf Student zu referenzieren.
Student.prototype.constructor = Student;

// Ersetzt die "sayHello" Methode
Student.prototype.sayHello = function(){
  console.log("Hello, I'm " + this.firstName + ". I'm studying "
              + this.subject + ".");
};

// Fügt die "sayGoodBye" Methode hinzu
Student.prototype.sayGoodBye = function(){
  console.log("Goodbye!");
};

// Beispieleinsatz:
var student1 = new Student("Janet", "Applied Physics");
student1.sayHello();   // "Hello, I'm Janet. I'm studying Applied Physics."
student1.walk();       // "I am walking!"
student1.sayGoodBye(); // "Goodbye!"

// Check that instanceof works correctly
console.log(student1 instanceof Person);  // true
console.log(student1 instanceof Student); // true
</pre>

<p>Unter Betrachtung der Zeile <code>Student.prototype = Object.create(Person.prototype);</code>: In älteren JavaScript Engines ohne <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" title="Object.create"><code>Object.create</code></a>, kann ein "polyfill" (auch "shim", siehe den verlinkten Artikel) oder eine Funktion, die dasselbe Ergebnis erzielt, verwendet werden:</p>

<pre class="brush: js">function createObject(proto) {
    function ctor() { }
    ctor.prototype = proto;
    return new ctor();
}

// Einsatz:
Student.prototype = createObject(Person.prototype);
</pre>

<div class="note">Lesen Sie <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" title="Object.create">Object.create</a>, um mehr zum obigen Beispiel zu erfahren.</div>

<p>Stellen sie sicher, dass <code>this</code> zum richtigen Objekt referenziert unabhängig davon, wie das Objekt erstellt wird. Es gibt eine einfache Methode dieses sicherzustellen:</p>

<pre>var Person = function(firstName) {
  if (this instanceof Person) {
    this.firstName = firstName
  } else {
    return new Person(firstName)
  }
}</pre>

<h4 id="Encapsulation" name="Encapsulation">Datenkapselung</h4>

<p>Im obigen Beispiel muss die <code>Student</code> Klasse nicht wissen, wie die Methode <code>walk()</code> der <code>Person</code> Klasse implementiert ist, um sie verwenden zu können. Die <code>Student</code> Klasse muss die Methode nicht explizit definierten, solange Sie unverändert übernommen werden soll. Dabei handelt es sich um <strong>Datenkapselung</strong>, bei der jede Klasse ihre Daten und Methoden in einer Einheit bündeln.</p>

<p>Information Hiding ist ein gängiges Feature in anderen Programmiersprachen, bei dem Methoden und Eigenschaften als privat oder geschützt definierten werden können. Obwohl Information Hiding mit JavaScript realisiert werden kann, ist es keine Voraussetzung für objektorientierte Programmierung.<a href="#cite-3"><sup>3</sup></a></p>

<h4 id="Abstraction" name="Abstraction">Abstraktion</h4>

<p>Abstraktion ist ein Mechanismus, der die Modellierung eines Teils der Problemstellung erlaubt. Dazu kann Vererbung (Spezialisierung) oder Komposition eingesetzt werden. JavaScript ermöglicht die Spezialisierung mit Vererbung. Komposition wird realiseirt, indem Instanzen einer Klasse als Werte von Eigenschaften eines Objekts gesetzt werden.</p>

<p>Die Function Klasse in JavaScript erbt von der Object Klasse (Spezialisierung). Die <code>Function.prototype</code> Eigenschaft ist eine Instanz der Object Klasse (Komposition).</p>

<pre class="brush: js">var foo = function(){};

// logs "foo is a Function: true"
console.log('foo is a Function: ' + (foo instanceof Function));

// logs "foo.prototype is an Object: true"
console.log('foo.prototype is an Object: ' + (foo.prototype instanceof Object));</pre>

<h4 id="Polymorphism" name="Polymorphism">Polymorphismus</h4>

<p>Wie alle Methoden und Eigenschaften innerhalb der <code>prototype</code> Eigenschaft definiert werden, können unterschiedliche Klassen Methoden mit demselben Namen definieren. Methoden sind im Scope der Klasse, in der sie definiert sind, verfügbar. Das gilt solange die Klassen keine parent-child Beziehung besitzen (wenn die eine Klasse nicht innerhalb einer Kette von der anderen Klasse erbt).</p>

<h2 id="Anmerkungen">Anmerkungen</h2>

<p>Die im Artikel präsentierten Techniken umfassen nicht alle Möglichkeiten der objektorientierten Programmierung in JavaScript, da JavaScript sehr flexibel in der Umsetzung der objektorientierten Programmierung ist.</p>

<p>Die vorgestellten Techniken zeigen nicht alle verfügbaren Hacks in JavaScript und mimen nicht die Implementierung der Objektorientiertheit in anderen Programmiersprachen.</p>

<p>Es gibt weitere Techniken, welche eine fortgeschrittenere objektorientierte Programmierung in JavaScript ermöglichen. Diese gehen aber über den Umfang dieses einführenden Artikels hinaus.</p>

<h2 id="References" name="References">Referenzen</h2>

<ol>
 <li><a name="cite-1"></a>Wikipedia. "<a href="https://en.wikipedia.org/wiki/Object-oriented_programming">Object-oriented programming</a>" und "<a href="https://de.wikipedia.org/wiki/Objektorientierte_Programmierung">Objektorientierte Programmierung</a>"</li>
 <li><a name="cite-2"></a>Wikipedia. "<a href="https://en.wikipedia.org/wiki/Prototype-based_programming" id="cite-2">Prototype-based programming</a>" und "<a href="https://de.wikipedia.org/wiki/Prototypenbasierte_Programmierung">Prototypenbasierte Programmierung</a>"</li>
 <li><a name="cite-3"></a>Wikipedia. "<a href="https://en.wikipedia.org/wiki/Encapsulation_%28object-oriented_programming%29">Encapsulation (object-oriented programming)</a>" und "<a href="https://de.wikipedia.org/wiki/Datenkapselung_%28Programmierung%29">Datenkapselung (Programmierung)</a>"</li>
</ol>

<h2 id="Siehe_auch">Siehe auch</h2>

<ul>
 <li>{{jsxref("Function.prototype.call()")}}</li>
 <li>{{jsxref("Function.prototype.apply()")}}</li>
 <li>{{jsxref("Object.create()")}}</li>
 <li>{{jsxref("Strict_mode", "Strict mode")}}</li>
</ul>
